webpackHotUpdate("vendor",{

/***/ "../node_modules/assert/assert.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) { // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }

  return !!(b != null && b._isBuffer);
} // based on node assert, original notice:
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");

var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;

var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }

  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


var assert = module.exports = ok; // 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }

  if (functionsHaveNames) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}; // assert.AssertionError instanceof Error


util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.


assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}

assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
}; // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);


assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
}; // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);


assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
}; // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);


assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
}; // EXTENSION! This is annoying to write outside this module.


assert.doesNotThrow = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
};

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }

  return keys;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/axios/index.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/axios/lib/axios.js");

/***/ }),

/***/ "../node_modules/axios/lib/adapters/http.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var settle = __webpack_require__("../node_modules/axios/lib/core/settle.js");

var buildURL = __webpack_require__("../node_modules/axios/lib/helpers/buildURL.js");

var http = __webpack_require__("../node_modules/tns-core-modules/http/http.js");

var https = __webpack_require__("../node_modules/https-browserify/index.js");

var httpFollow = __webpack_require__("../node_modules/follow-redirects/index.js").http;

var httpsFollow = __webpack_require__("../node_modules/follow-redirects/index.js").https;

var url = __webpack_require__("../node_modules/url/url.js");

var zlib = __webpack_require__("../node_modules/browserify-zlib/lib/index.js");

var pkg = __webpack_require__("../node_modules/axios/package.json");

var createError = __webpack_require__("../node_modules/axios/lib/core/createError.js");

var enhanceError = __webpack_require__("../node_modules/axios/lib/core/enhanceError.js");

var isHttps = /https:?/;
/*eslint consistent-return:0*/

module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    var timer;

    var resolve = function resolve(value) {
      clearTimeout(timer);
      resolvePromise(value);
    };

    var reject = function reject(value) {
      clearTimeout(timer);
      rejectPromise(value);
    };

    var data = config.data;
    var headers = config.headers; // Set User-Agent (required by some servers)
    // Only set header if it hasn't been set in config
    // See https://github.com/axios/axios/issues/69

    if (!headers['User-Agent'] && !headers['user-agent']) {
      headers['User-Agent'] = 'axios/' + pkg.version;
    }

    if (data && !utils.isStream(data)) {
      if (Buffer.isBuffer(data)) {// Nothing to do...
      } else if (utils.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(createError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', config));
      } // Add Content-Length header if data exists


      headers['Content-Length'] = data.length;
    } // HTTP basic authentication


    var auth = undefined;

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      auth = username + ':' + password;
    } // Parse url


    var parsed = url.parse(config.url);
    var protocol = parsed.protocol || 'http:';

    if (!auth && parsed.auth) {
      var urlAuth = parsed.auth.split(':');
      var urlUsername = urlAuth[0] || '';
      var urlPassword = urlAuth[1] || '';
      auth = urlUsername + ':' + urlPassword;
    }

    if (auth) {
      delete headers.Authorization;
    }

    var isHttpsRequest = isHttps.test(protocol);
    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    var options = {
      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
      method: config.method.toUpperCase(),
      headers: headers,
      agent: agent,
      auth: auth
    };

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
    }

    var proxy = config.proxy;

    if (!proxy && proxy !== false) {
      var proxyEnv = protocol.slice(0, -1) + '_proxy';
      var proxyUrl = global.process.env[proxyEnv] || global.process.env[proxyEnv.toUpperCase()];

      if (proxyUrl) {
        var parsedProxyUrl = url.parse(proxyUrl);
        var noProxyEnv = global.process.env.no_proxy || global.process.env.NO_PROXY;
        var shouldProxy = true;

        if (noProxyEnv) {
          var noProxy = noProxyEnv.split(',').map(function trim(s) {
            return s.trim();
          });
          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
            if (!proxyElement) {
              return false;
            }

            if (proxyElement === '*') {
              return true;
            }

            if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement && proxyElement.match(/\./g).length === parsed.hostname.match(/\./g).length) {
              return true;
            }

            return parsed.hostname === proxyElement;
          });
        }

        if (shouldProxy) {
          proxy = {
            host: parsedProxyUrl.hostname,
            port: parsedProxyUrl.port
          };

          if (parsedProxyUrl.auth) {
            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
            proxy.auth = {
              username: proxyUrlAuth[0],
              password: proxyUrlAuth[1]
            };
          }
        }
      }
    }

    if (proxy) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
      options.port = proxy.port;
      options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path; // Basic proxy authorization

      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
        options.headers['Proxy-Authorization'] = 'Basic ' + base64;
      }
    }

    var transport;
    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);

    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsProxy ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }

      transport = isHttpsProxy ? httpsFollow : httpFollow;
    }

    if (config.maxContentLength && config.maxContentLength > -1) {
      options.maxBodyLength = config.maxContentLength;
    } // Create the request


    var req = transport.request(options, function handleResponse(res) {
      if (req.aborted) return; // uncompress the response body transparently if required

      var stream = res;

      switch (res.headers['content-encoding']) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'compress':
        case 'deflate':
          // add the unzipper to the body stream processing pipeline
          stream = res.statusCode === 204 ? stream : stream.pipe(zlib.createUnzip()); // remove the content-encoding in order to not confuse downstream operations

          delete res.headers['content-encoding'];
          break;
      } // return the last request in case of redirects


      var lastRequest = res.req || req;
      var response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: config,
        request: lastRequest
      };

      if (config.responseType === 'stream') {
        response.data = stream;
        settle(resolve, reject, response);
      } else {
        var responseBuffer = [];
        stream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk); // make sure the content length is not over the maxContentLength if specified

          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
            stream.destroy();
            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config, null, lastRequest));
          }
        });
        stream.on('error', function handleStreamError(err) {
          if (req.aborted) return;
          reject(enhanceError(err, config, null, lastRequest));
        });
        stream.on('end', function handleStreamEnd() {
          var responseData = Buffer.concat(responseBuffer);

          if (config.responseType !== 'arraybuffer') {
            responseData = responseData.toString(config.responseEncoding);
          }

          response.data = responseData;
          settle(resolve, reject, response);
        });
      }
    }); // Handle errors

    req.on('error', function handleRequestError(err) {
      if (req.aborted) return;
      reject(enhanceError(err, config, null, req));
    }); // Handle request timeout

    if (config.timeout) {
      timer = setTimeout(function handleRequestTimeout() {
        req.abort();
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));
      }, config.timeout);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (req.aborted) return;
        req.abort();
        reject(cancel);
      });
    } // Send the request


    if (utils.isStream(data)) {
      data.on('error', function handleStreamError(err) {
        reject(enhanceError(err, config, null, req));
      }).pipe(req);
    } else {
      req.end(data);
    }
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/axios/lib/adapters/xhr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var settle = __webpack_require__("../node_modules/axios/lib/core/settle.js");

var buildURL = __webpack_require__("../node_modules/axios/lib/helpers/buildURL.js");

var parseHeaders = __webpack_require__("../node_modules/axios/lib/helpers/parseHeaders.js");

var isURLSameOrigin = __webpack_require__("../node_modules/axios/lib/helpers/isURLSameOrigin.js");

var createError = __webpack_require__("../node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__("../node_modules/axios/lib/helpers/cookies.js"); // Add xsrf header


      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (config.withCredentials) {
      request.withCredentials = true;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ "../node_modules/axios/lib/axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var bind = __webpack_require__("../node_modules/axios/lib/helpers/bind.js");

var Axios = __webpack_require__("../node_modules/axios/lib/core/Axios.js");

var mergeConfig = __webpack_require__("../node_modules/axios/lib/core/mergeConfig.js");

var defaults = __webpack_require__("../node_modules/axios/lib/defaults.js");
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__("../node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__("../node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__("../node_modules/axios/lib/cancel/isCancel.js"); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__("../node_modules/axios/lib/helpers/spread.js");
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports.default = axios;

/***/ }),

/***/ "../node_modules/axios/lib/cancel/Cancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),

/***/ "../node_modules/axios/lib/cancel/CancelToken.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__("../node_modules/axios/lib/cancel/Cancel.js");
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "../node_modules/axios/lib/cancel/isCancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "../node_modules/axios/lib/core/Axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var buildURL = __webpack_require__("../node_modules/axios/lib/helpers/buildURL.js");

var InterceptorManager = __webpack_require__("../node_modules/axios/lib/core/InterceptorManager.js");

var dispatchRequest = __webpack_require__("../node_modules/axios/lib/core/dispatchRequest.js");

var mergeConfig = __webpack_require__("../node_modules/axios/lib/core/mergeConfig.js");
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);
  config.method = config.method ? config.method.toLowerCase() : 'get'; // Hook up interceptors middleware

  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),

/***/ "../node_modules/axios/lib/core/InterceptorManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "../node_modules/axios/lib/core/createError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__("../node_modules/axios/lib/core/enhanceError.js");
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "../node_modules/axios/lib/core/dispatchRequest.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var transformData = __webpack_require__("../node_modules/axios/lib/core/transformData.js");

var isCancel = __webpack_require__("../node_modules/axios/lib/cancel/isCancel.js");

var defaults = __webpack_require__("../node_modules/axios/lib/defaults.js");

var isAbsoluteURL = __webpack_require__("../node_modules/axios/lib/helpers/isAbsoluteURL.js");

var combineURLs = __webpack_require__("../node_modules/axios/lib/helpers/combineURLs.js");
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Support baseURL config

  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  } // Ensure headers exist


  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "../node_modules/axios/lib/core/enhanceError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function () {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),

/***/ "../node_modules/axios/lib/core/mergeConfig.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });
  utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  utils.forEach(['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath'], function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  return config;
};

/***/ }),

/***/ "../node_modules/axios/lib/core/settle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__("../node_modules/axios/lib/core/createError.js");
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "../node_modules/axios/lib/core/transformData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

/***/ }),

/***/ "../node_modules/axios/lib/defaults.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var normalizeHeaderName = __webpack_require__("../node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter; // Only Node.JS has a process variable that is of [[Class]] process

  if (typeof global.process !== 'undefined' && Object.prototype.toString.call(global.process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__("../node_modules/axios/lib/adapters/http.js");
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__("../node_modules/axios/lib/adapters/xhr.js");
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

/***/ }),

/***/ "../node_modules/axios/lib/helpers/bind.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/buildURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/combineURLs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/cookies.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "../node_modules/axios/lib/helpers/isAbsoluteURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/isURLSameOrigin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "../node_modules/axios/lib/helpers/normalizeHeaderName.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/parseHeaders.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js"); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/spread.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "../node_modules/axios/lib/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__("../node_modules/axios/lib/helpers/bind.js");

var isBuffer = __webpack_require__("../node_modules/is-buffer/index.js");
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function deepMerge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};

/***/ }),

/***/ "../node_modules/axios/package.json":
/***/ (function(module) {

module.exports = {"_from":"axios@^0.19.0","_id":"axios@0.19.0","_inBundle":false,"_integrity":"sha512-1uvKqKQta3KBxIz14F2v06AEHZ/dIoeKfbTRkK1E5oqjDnuEerLmYTgJB5AiQZHJcljpg1TuRzdjDR06qNk0DQ==","_location":"/axios","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"axios@^0.19.0","name":"axios","escapedName":"axios","rawSpec":"^0.19.0","saveSpec":null,"fetchSpec":"^0.19.0"},"_requiredBy":["/schmucklicloud_auth"],"_resolved":"https://registry.npmjs.org/axios/-/axios-0.19.0.tgz","_shasum":"8e09bff3d9122e133f7b8101c8fbdd00ed3d2ab8","_spec":"axios@^0.19.0","_where":"/Users/julian/Projects/NativeScript/todo_app/node_modules/schmucklicloud_auth","author":{"name":"Matt Zabriskie"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"bugs":{"url":"https://github.com/axios/axios/issues"},"bundleDependencies":false,"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}],"dependencies":{"follow-redirects":"1.5.10","is-buffer":"^2.0.2"},"deprecated":false,"description":"Promise based HTTP client for the browser and node.js","devDependencies":{"bundlesize":"^0.17.0","coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.0.2","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^20.1.0","grunt-karma":"^2.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^1.0.18","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^1.3.0","karma-chrome-launcher":"^2.2.0","karma-coverage":"^1.1.1","karma-firefox-launcher":"^1.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-opera-launcher":"^1.0.0","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^1.2.0","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.7","karma-webpack":"^1.7.0","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^5.2.0","sinon":"^4.5.0","typescript":"^2.8.1","url-search-params":"^0.10.0","webpack":"^1.13.1","webpack-dev-server":"^1.14.1"},"homepage":"https://github.com/axios/axios","keywords":["xhr","http","ajax","promise","node"],"license":"MIT","main":"index.js","name":"axios","repository":{"type":"git","url":"git+https://github.com/axios/axios.git"},"scripts":{"build":"NODE_ENV=production grunt build","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","examples":"node ./examples/server.js","fix":"eslint --fix lib/**/*.js","postversion":"git push && git push --tags","preversion":"npm test","start":"node ./sandbox/server.js","test":"grunt test && bundlesize","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json"},"typings":"./index.d.ts","version":"0.19.0"};

/***/ }),

/***/ "../node_modules/base64-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "../node_modules/browserify-zlib/lib/binding.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
/* eslint camelcase: "off" */

var assert = __webpack_require__("../node_modules/assert/assert.js");

var Zstream = __webpack_require__("../node_modules/pako/lib/zlib/zstream.js");

var zlib_deflate = __webpack_require__("../node_modules/pako/lib/zlib/deflate.js");

var zlib_inflate = __webpack_require__("../node_modules/pako/lib/zlib/inflate.js");

var constants = __webpack_require__("../node_modules/pako/lib/zlib/constants.js");

for (var key in constants) {
  exports[key] = constants[key];
} // zlib modes


exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;
var GZIP_HEADER_ID1 = 0x1f;
var GZIP_HEADER_ID2 = 0x8b;
/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */

function Zlib(mode) {
  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {
    throw new TypeError('Bad argument');
  }

  this.dictionary = null;
  this.err = 0;
  this.flush = 0;
  this.init_done = false;
  this.level = 0;
  this.memLevel = 0;
  this.mode = mode;
  this.strategy = 0;
  this.windowBits = 0;
  this.write_in_progress = false;
  this.pending_close = false;
  this.gzip_id_bytes_read = 0;
}

Zlib.prototype.close = function () {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }

  this.pending_close = false;
  assert(this.init_done, 'close before init');
  assert(this.mode <= exports.UNZIP);

  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
    zlib_inflate.inflateEnd(this.strm);
  }

  this.mode = exports.NONE;
  this.dictionary = null;
};

Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {
  assert.equal(arguments.length, 8);
  assert(this.init_done, 'write before init');
  assert(this.mode !== exports.NONE, 'already finalized');
  assert.equal(false, this.write_in_progress, 'write already in progress');
  assert.equal(false, this.pending_close, 'close is pending');
  this.write_in_progress = true;
  assert.equal(false, flush === undefined, 'must provide flush value');
  this.write_in_progress = true;

  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
    throw new Error('Invalid flush value');
  }

  if (input == null) {
    input = Buffer.alloc(0);
    in_len = 0;
    in_off = 0;
  }

  this.strm.avail_in = in_len;
  this.strm.input = input;
  this.strm.next_in = in_off;
  this.strm.avail_out = out_len;
  this.strm.output = out;
  this.strm.next_out = out_off;
  this.flush = flush;

  if (!async) {
    // sync version
    this._process();

    if (this._checkError()) {
      return this._afterSync();
    }

    return;
  } // async version


  var self = this;
  global.process.nextTick(function () {
    self._process();

    self._after();
  });
  return this;
};

Zlib.prototype._afterSync = function () {
  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false;
  return [avail_in, avail_out];
};

Zlib.prototype._process = function () {
  var next_expected_header_byte = null; // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflate(this.strm, this.flush);
      break;

    case exports.UNZIP:
      if (this.strm.avail_in > 0) {
        next_expected_header_byte = this.strm.next_in;
      }

      switch (this.gzip_id_bytes_read) {
        case 0:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
            this.gzip_id_bytes_read = 1;
            next_expected_header_byte++;

            if (this.strm.avail_in === 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            this.mode = exports.INFLATE;
            break;
          }

        // fallthrough

        case 1:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
            this.gzip_id_bytes_read = 2;
            this.mode = exports.GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            this.mode = exports.INFLATE;
          }

          break;

        default:
          throw new Error('invalid number of gzip magic number bytes read');
      }

    // fallthrough

    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      this.err = zlib_inflate.inflate(this.strm, this.flush // If data was encoded with dictionary
      );

      if (this.err === exports.Z_NEED_DICT && this.dictionary) {
        // Load it
        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);

        if (this.err === exports.Z_OK) {
          // And try to decode again
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        } else if (this.err === exports.Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          this.err = exports.Z_NEED_DICT;
        }
      }

      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.
        this.reset();
        this.err = zlib_inflate.inflate(this.strm, this.flush);
      }

      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }
};

Zlib.prototype._checkError = function () {
  // Acceptable error states depend on the type of zlib stream.
  switch (this.err) {
    case exports.Z_OK:
    case exports.Z_BUF_ERROR:
      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
        this._error('unexpected end of file');

        return false;
      }

      break;

    case exports.Z_STREAM_END:
      // normal statuses, not fatal
      break;

    case exports.Z_NEED_DICT:
      if (this.dictionary == null) {
        this._error('Missing dictionary');
      } else {
        this._error('Bad dictionary');
      }

      return false;

    default:
      // something else.
      this._error('Zlib error');

      return false;
  }

  return true;
};

Zlib.prototype._after = function () {
  if (!this._checkError()) {
    return;
  }

  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false; // call the write() cb

  this.callback(avail_in, avail_out);

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype._error = function (message) {
  if (this.strm.msg) {
    message = this.strm.msg;
  }

  this.onerror(message, this.err // no hope of rescue.
  );
  this.write_in_progress = false;

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');
  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');
  assert(level >= -1 && level <= 9, 'invalid compression level');
  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');
  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');

  this._init(level, windowBits, memLevel, strategy, dictionary);

  this._setDictionary();
};

Zlib.prototype.params = function () {
  throw new Error('deflateParams Not supported');
};

Zlib.prototype.reset = function () {
  this._reset();

  this._setDictionary();
};

Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {
  this.level = level;
  this.windowBits = windowBits;
  this.memLevel = memLevel;
  this.strategy = strategy;
  this.flush = exports.Z_NO_FLUSH;
  this.err = exports.Z_OK;

  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
    this.windowBits += 16;
  }

  if (this.mode === exports.UNZIP) {
    this.windowBits += 32;
  }

  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
    this.windowBits = -1 * this.windowBits;
  }

  this.strm = new Zstream();

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
      break;

    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }

  if (this.err !== exports.Z_OK) {
    this._error('Init error');
  }

  this.dictionary = dictionary;
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype._setDictionary = function () {
  if (this.dictionary == null) {
    return;
  }

  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
      break;

    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to set dictionary');
  }
};

Zlib.prototype._reset = function () {
  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
    case exports.GZIP:
      this.err = zlib_deflate.deflateReset(this.strm);
      break;

    case exports.INFLATE:
    case exports.INFLATERAW:
    case exports.GUNZIP:
      this.err = zlib_inflate.inflateReset(this.strm);
      break;

    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to reset stream');
  }
};

exports.Zlib = Zlib;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/browserify-zlib/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__("../node_modules/buffer/index.js").Buffer;

var Transform = __webpack_require__("../node_modules/stream-browserify/index.js").Transform;

var binding = __webpack_require__("../node_modules/browserify-zlib/lib/binding.js");

var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");

var assert = __webpack_require__("../node_modules/assert/assert.js").ok;

var kMaxLength = __webpack_require__("../node_modules/buffer/index.js").kMaxLength;

var kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes'; // zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.

binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.

binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = 16 * 1024;
binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;
binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION; // expose all the zlib constants

var bkeys = Object.keys(binding);

for (var bk = 0; bk < bkeys.length; bk++) {
  var bkey = bkeys[bk];

  if (bkey.match(/^Z/)) {
    Object.defineProperty(exports, bkey, {
      enumerable: true,
      value: binding[bkey],
      writable: false
    });
  }
} // translation table for return codes.


var codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};
var ckeys = Object.keys(codes);

for (var ck = 0; ck < ckeys.length; ck++) {
  var ckey = ckeys[ck];
  codes[codes[ckey]] = ckey;
}

Object.defineProperty(exports, 'codes', {
  enumerable: true,
  value: Object.freeze(codes),
  writable: false
});
exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function (o) {
  return new Deflate(o);
};

exports.createInflate = function (o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function (o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function (o) {
  return new InflateRaw(o);
};

exports.createGzip = function (o) {
  return new Gzip(o);
};

exports.createGunzip = function (o) {
  return new Gunzip(o);
};

exports.createUnzip = function (o) {
  return new Unzip(o);
}; // Convenience methods.
// compress/decompress a string or buffer in one step.


exports.deflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function (buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function (buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function (buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;
  engine.on('error', onError);
  engine.on('end', onEnd);
  engine.end(buffer);
  flow();

  function flow() {
    var chunk;

    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }

    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf;
    var err = null;

    if (nread >= kMaxLength) {
      err = new RangeError(kRangeErrorMessage);
    } else {
      buf = Buffer.concat(buffers, nread);
    }

    buffers = [];
    engine.close();
    callback(err, buf);
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') buffer = Buffer.from(buffer);
  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');
  var flushFlag = engine._finishFlushFlag;
  return engine._processChunk(buffer, flushFlag);
} // generic zlib
// minimal 2-byte header


function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
} // gzip - bigger header, same deflate compression


function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
} // raw - no header


function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
} // auto-detect header.


function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}

function isValidFlushFlag(flag) {
  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
} // the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.


function Zlib(opts, mode) {
  var _this = this;

  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
  Transform.call(this, opts);

  if (opts.flush && !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }

  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);
  var self = this;
  this._hadError = false;

  this._handle.onerror = function (message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);

    self._hadError = true;
    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;
  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;
  this.once('end', this.close);
  Object.defineProperty(this, '_closed', {
    get: function get() {
      return !_this._handle;
    },
    configurable: true,
    enumerable: true
  });
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function (level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }

  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function () {
      assert(self._handle, 'zlib binding closed');

      self._handle.params(level, strategy);

      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    global.process.nextTick(callback);
  }
};

Zlib.prototype.reset = function () {
  assert(this._handle, 'zlib binding closed');
  return this._handle.reset();
}; // This is the _flush function called by the transform class,
// internally, when the last chunk has been written.


Zlib.prototype._flush = function (callback) {
  this._transform(Buffer.alloc(0), '', callback);
};

Zlib.prototype.flush = function (kind, callback) {
  var _this2 = this;

  var ws = this._writableState;

  if (typeof kind === 'function' || kind === undefined && !callback) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback) global.process.nextTick(callback);
  } else if (ws.ending) {
    if (callback) this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', function () {
        return _this2.flush(kind, callback);
      });
    }
  } else {
    this._flushFlag = kind;
    this.write(Buffer.alloc(0), '', callback);
  }
};

Zlib.prototype.close = function (callback) {
  _close(this, callback);

  global.process.nextTick(emitCloseNT, this);
};

function _close(engine, callback) {
  if (callback) global.process.nextTick(callback); // Caller may invoke .close after a zlib error (which will null _handle).

  if (!engine._handle) return;

  engine._handle.close();

  engine._handle = null;
}

function emitCloseNT(self) {
  self.emit('close');
}

Zlib.prototype._transform = function (chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);
  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));
  if (!this._handle) return cb(new Error('zlib binding closed')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.

  if (last) flushFlag = this._finishFlushFlag;else {
    flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.

    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;
  var self = this;
  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;
    var error;
    this.on('error', function (er) {
      error = er;
    });
    assert(this._handle, 'zlib binding closed');

    do {
      var res = this._handle.writeSync(flushFlag, chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore); // out_len

    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    if (nread >= kMaxLength) {
      _close(this);

      throw new RangeError(kRangeErrorMessage);
    }

    var buf = Buffer.concat(buffers, nread);

    _close(this);

    return buf;
  }

  assert(this._handle, 'zlib binding closed');

  var req = this._handle.write(flushFlag, chunk, // in
  inOff, // in_off
  availInBefore, // in_len
  this._buffer, // out
  this._offset, //out_off
  availOutBefore); // out_len


  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }

    if (self._hadError) return;
    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);

      self._offset += have; // serve some output to the consumer.

      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    } // exhausted the output buffer, or used all the input create a new one.


    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;
      if (!async) return true;

      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);

      newReq.callback = callback; // this same function

      newReq.buffer = chunk;
      return;
    }

    if (!async) return false; // finished with the chunk.

    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

/***/ }),

/***/ "../node_modules/buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__("../node_modules/base64-js/index.js");

var ieee754 = __webpack_require__("../node_modules/ieee754/index.js");

var isArray = __webpack_require__("../node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/core-util-is/lib/util.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/debug/src/browser.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
exports = module.exports = __webpack_require__("../node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  } // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */


exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  var useColors = this.useColors;
  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
  if (!useColors) return;
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;

    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.debug;
  } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof global.process !== 'undefined' && 'env' in global.process) {
    r = global.process.env.DEBUG;
  }

  return r;
}
/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */


exports.enable(load());
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/***/ }),

/***/ "../node_modules/debug/src/debug.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__("../node_modules/ms/index.js");
/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];
/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};
/**
 * Previous log timestamp.
 */

var prevTime;
/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}
/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */


function createDebug(namespace) {
  function debug() {
    // disabled?
    if (!debug.enabled) return;
    var self = debug; // set `diff` timestamp

    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr; // turn the `arguments` into a proper Array

    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    } // apply any `formatters` transformations


    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];

      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

        args.splice(index, 1);
        index--;
      }

      return match;
    }); // apply env-specific formatting (colors, etc.)

    exports.formatArgs.call(self, args);
    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace); // env-specific initialization logic for debug instances

  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}
/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */


function enable(namespaces) {
  exports.save(namespaces);
  exports.names = [];
  exports.skips = [];
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings

    namespaces = split[i].replace(/\*/g, '.*?');

    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}
/**
 * Disable debug output.
 *
 * @api public
 */


function disable() {
  exports.enable('');
}
/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */


function enabled(name) {
  var i, len;

  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }

  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }

  return false;
}
/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */


function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

/***/ }),

/***/ "../node_modules/debug/src/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */
if (typeof global.process !== 'undefined' && global.process.type === 'renderer') {
  module.exports = __webpack_require__("../node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__("../node_modules/debug/src/node.js");
}

/***/ }),

/***/ "../node_modules/debug/src/node.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */
var tty = __webpack_require__("../node_modules/tty-browserify/index.js");

var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");
/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */


exports = module.exports = __webpack_require__("../node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(global.process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  }); // coerce string value into JS value

  var val = global.process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);
  obj[prop] = val;
  return obj;
}, {});
/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(global.process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? global.process.stdout : 2 === fd ? global.process.stderr : createWritableStdioStream(fd);
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}
/**
 * Map %o to `util.inspect()`, all on a single line.
 */


exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};
/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */


exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';
    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}
/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */


function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete global.process.env.DEBUG;
  } else {
    global.process.env.DEBUG = namespaces;
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  return global.process.env.DEBUG;
}
/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */


function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = global.process.binding('tty_wrap'); // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty'; // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726

      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }

      break;

    case 'FILE':
      var fs = __webpack_require__("../node_modules/node-libs-browser/mock/empty.js");

      stream = new fs.SyncWriteStream(fd, {
        autoClose: false
      });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__("../node_modules/net/index.js");

      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      }); // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd

      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe'; // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726

      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }

      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  } // For supporting legacy API we put the FD here.


  stream.fd = fd;
  stream._isStdio = true;
  return stream;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */


function init(debug) {
  debug.inspectOpts = {};
  var keys = Object.keys(exports.inspectOpts);

  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}
/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */


exports.enable(load());

/***/ }),

/***/ "../node_modules/events/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = $getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];

  for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

/***/ }),

/***/ "../node_modules/follow-redirects/index.js":
/***/ (function(module, exports, __webpack_require__) {

var url = __webpack_require__("../node_modules/url/url.js");

var http = __webpack_require__("../node_modules/tns-core-modules/http/http.js");

var https = __webpack_require__("../node_modules/https-browserify/index.js");

var assert = __webpack_require__("../node_modules/assert/assert.js");

var Writable = __webpack_require__("../node_modules/stream-browserify/index.js").Writable;

var debug = __webpack_require__("../node_modules/debug/src/index.js")("follow-redirects"); // RFC7231§4.2.1: Of the request methods defined by this specification,
// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.


var SAFE_METHODS = {
  GET: true,
  HEAD: true,
  OPTIONS: true,
  TRACE: true
}; // Create handlers that pass events from native requests

var eventHandlers = Object.create(null);
["abort", "aborted", "error", "socket", "timeout"].forEach(function (event) {
  eventHandlers[event] = function (arg) {
    this._redirectable.emit(event, arg);
  };
}); // An HTTP(S) request that can be redirected

function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  options.headers = options.headers || {};
  this._options = options;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = []; // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.

  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }

    delete options.host;
  } // Attach a callback if passed


  if (responseCallback) {
    this.on("response", responseCallback);
  } // React to responses of native requests


  var self = this;

  this._onNativeResponse = function (response) {
    self._processResponse(response);
  }; // Complete the URL object when necessary


  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");

    if (searchPos < 0) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  } // Perform the first request


  this._performRequest();
}

RedirectableRequest.prototype = Object.create(Writable.prototype); // Writes buffered data to the current native request

RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Validate input and shift parameters if necessary
  if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
    throw new Error("data should be a string, Buffer or Uint8Array");
  }

  if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  } // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066


  if (data.length === 0) {
    if (callback) {
      callback();
    }

    return;
  } // Only write when we don't exceed the maximum body length


  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;

    this._requestBodyBuffers.push({
      data: data,
      encoding: encoding
    });

    this._currentRequest.write(data, encoding, callback);
  } // Error when we exceed the maximum body length
  else {
      this.emit("error", new Error("Request body larger than maxBodyLength limit"));
      this.abort();
    }
}; // Ends the current native request


RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (typeof data === "function") {
    callback = data;
    data = encoding = null;
  } else if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  } // Write data and end


  var currentRequest = this._currentRequest;
  this.write(data || "", encoding, function () {
    currentRequest.end(null, null, callback);
  });
}; // Sets a header value on the current native request


RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;

  this._currentRequest.setHeader(name, value);
}; // Clears a header value on the current native request


RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];

  this._currentRequest.removeHeader(name);
}; // Proxy all other public ClientRequest methods


["abort", "flushHeaders", "getHeader", "setNoDelay", "setSocketKeepAlive", "setTimeout"].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
}); // Proxy all public ClientRequest properties

["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function get() {
      return this._currentRequest[property];
    }
  });
}); // Executes the next native request (initial or redirect)

RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];

  if (!nativeProtocol) {
    this.emit("error", new Error("Unsupported protocol " + protocol));
    return;
  } // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)


  if (this._options.agents) {
    var scheme = protocol.substr(0, protocol.length - 1);
    this._options.agent = this._options.agents[scheme];
  } // Create the native request


  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  this._currentUrl = url.format(this._options); // Set up event handlers

  request._redirectable = this;

  for (var event in eventHandlers) {
    /* istanbul ignore else */
    if (event) {
      request.on(event, eventHandlers[event]);
    }
  } // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)


  if (this._isRedirect) {
    // Write the request entity and end.
    var i = 0;
    var buffers = this._requestBodyBuffers;

    (function writeNext() {
      if (i < buffers.length) {
        var buffer = buffers[i++];
        request.write(buffer.data, buffer.encoding, writeNext);
      } else {
        request.end();
      }
    })();
  }
}; // Processes a response from the current native request


RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: response.statusCode
    });
  } // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.


  var location = response.headers.location;

  if (location && this._options.followRedirects !== false && response.statusCode >= 300 && response.statusCode < 400) {
    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
      this.emit("error", new Error("Max redirects exceeded."));
      return;
    } // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe […],
    // since the user might not wish to redirect an unsafe request.
    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates
    // that the target resource resides temporarily under a different URI
    // and the user agent MUST NOT change the request method
    // if it performs an automatic redirection to that URI.


    var header;
    var headers = this._options.headers;

    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {
      this._options.method = "GET"; // Drop a possible entity and headers related to it

      this._requestBodyBuffers = [];

      for (header in headers) {
        if (/^content-/i.test(header)) {
          delete headers[header];
        }
      }
    } // Drop the Host header, as the redirect might lead to a different host


    if (!this._isRedirect) {
      for (header in headers) {
        if (/^host$/i.test(header)) {
          delete headers[header];
        }
      }
    } // Perform the redirected request


    var redirectUrl = url.resolve(this._currentUrl, location);
    debug("redirecting to", redirectUrl);
    Object.assign(this._options, url.parse(redirectUrl));
    this._isRedirect = true;

    this._performRequest(); // Discard the remainder of the response to avoid waiting for data


    response.destroy();
  } else {
    // The response is not a redirect; return it as-is
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response); // Clean up

    this._requestBodyBuffers = [];
  }
}; // Wraps the key/value object of protocols with redirect functionality


function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  }; // Wrap each protocol

  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol); // Executes a request, following redirects

    wrappedProtocol.request = function (options, callback) {
      if (typeof options === "string") {
        options = url.parse(options);
        options.maxRedirects = exports.maxRedirects;
      } else {
        options = Object.assign({
          protocol: protocol,
          maxRedirects: exports.maxRedirects,
          maxBodyLength: exports.maxBodyLength
        }, options);
      }

      options.nativeProtocols = nativeProtocols;
      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }; // Executes a GET request, following redirects


    wrappedProtocol.get = function (options, callback) {
      var request = wrappedProtocol.request(options, callback);
      request.end();
      return request;
    };
  });
  return exports;
} // Exports


module.exports = wrap({
  http: http,
  https: https
});
module.exports.wrap = wrap;

/***/ }),

/***/ "../node_modules/https-browserify/index.js":
/***/ (function(module, exports, __webpack_require__) {

var http = __webpack_require__("../node_modules/tns-core-modules/http/http.js");

var url = __webpack_require__("../node_modules/url/url.js");

var https = module.exports;

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key];
}

https.request = function (params, cb) {
  params = validateParams(params);
  return http.request.call(this, params, cb);
};

https.get = function (params, cb) {
  params = validateParams(params);
  return http.get.call(this, params, cb);
};

function validateParams(params) {
  if (typeof params === 'string') {
    params = url.parse(params);
  }

  if (!params.protocol) {
    params.protocol = 'https:';
  }

  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
  }

  return params;
}

/***/ }),

/***/ "../node_modules/ieee754/index.js":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "../node_modules/inherits/inherits.js":
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");
  /* istanbul ignore next */


  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__("../node_modules/inherits/inherits_browser.js");
}

/***/ }),

/***/ "../node_modules/inherits/inherits_browser.js":
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "../node_modules/is-buffer/index.js":
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),

/***/ "../node_modules/isarray/index.js":
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "../node_modules/ms/index.js":
/***/ (function(module, exports) {

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, n, name) {
  if (ms < n) {
    return;
  }

  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }

  return Math.ceil(ms / n) + ' ' + name + 's';
}

/***/ }),

/***/ "../node_modules/net/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
Copyright 2013 Sleepless Software Inc. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE. 
*/
// yes, I know this seems stupid, but I have my reasons.
var net = __webpack_require__("../node_modules/net/index.js");

for (k in net) {
  global[k] = net[k];
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof global == 'object' && global;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw new RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;;
          /* no condition */
          k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.4.1',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/module.js")(module), __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__("../node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/util/support/isBuffer.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function isBuffer(arg) {
  return arg instanceof Buffer;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/util/util.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof global.process !== 'undefined' && global.process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof global.process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (global.process.throwDeprecation) {
        throw new Error(msg);
      } else if (global.process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = global.process.env.NODE_DEBUG || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = global.process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/support/isBuffer.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = __webpack_require__("../node_modules/inherits/inherits.js");

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function cb() {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      global.process.nextTick(cb, null, ret);
    }, function (rej) {
      global.process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;

/***/ }),

/***/ "../node_modules/pako/lib/utils/common.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj
/*from1, from2, from3, ...*/
) {
  var sources = Array.prototype.slice.call(arguments, 1);

  while (sources.length) {
    var source = sources.shift();

    if (!source) {
      continue;
    }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
}; // reduce buffer size, avoiding mem copy


exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }

  if (buf.subarray) {
    return buf.subarray(0, size);
  }

  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    } // Fallback to ordinary array


    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result; // calculate data length

    len = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    } // join chunks


    result = new Uint8Array(len);
    pos = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};
var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
}; // Enable/Disable typed arrays use, for testing
//

exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

/***/ }),

/***/ "../node_modules/pako/lib/zlib/adler32.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

/***/ }),

/***/ "../node_modules/pako/lib/zlib/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/crc32.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

/***/ }),

/***/ "../node_modules/pako/lib/zlib/deflate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");

var trees = __webpack_require__("../node_modules/pako/lib/zlib/trees.js");

var adler32 = __webpack_require__("../node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__("../node_modules/pako/lib/zlib/crc32.js");

var msg = __webpack_require__("../node_modules/pako/lib/zlib/messages.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */


var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5; //var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;

var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/* The deflate compression method */

var Z_DEFLATED = 8;
/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 0x20;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
/* block not completed, need more input or more output */

var BS_BLOCK_DONE = 2;
/* block flush performed */

var BS_FINISH_STARTED = 3;
/* finish started, need only more output at next deflate */

var BS_FINISH_DONE = 4;
/* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
}
/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */


function flush_pending(strm) {
  var s = strm.state; //_tr_flush_bits(s);

  var len = s.pending;

  if (len > strm.avail_out) {
    len = strm.avail_out;
  }

  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;

  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */


function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}
/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */


function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }

  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

  utils.arraySet(buf, strm.input, strm.next_in, len, start);

  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;
  return len;
}
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */


function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  /* max hash chain length */

  var scan = s.strstart;
  /* current string */

  var match;
  /* matched string */

  var len;
  /* length of current match */

  var best_len = s.prev_length;
  /* best match length so far */

  var nice_match = s.nice_match;
  /* stop if match long enough */

  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
  /*NIL*/
  ;
  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;
  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */

  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */


  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;
    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */


    scan += 2;
    match++; // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */

    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;

      if (len >= nice_match) {
        break;
      }

      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }

  return s.lookahead;
}
/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */


function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */

    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */

      s.block_start -= _w_size;
      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }

    if (s.strm.avail_in === 0) {
      break;
    }
    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");


    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    /* Initialize the hash value now that we have some input: */

    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif

      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;

        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");

}
/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */


function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  /* Copy as much as possible from input to output: */


  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {
      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }
      fill_window(s);

      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    } //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");


    s.strstart += s.lookahead;
    s.lookahead = 0;
    /* Emit a stored block if pending_buf will be full: */

    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/

      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */


    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_NEED_MORE;
}
/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */


function deflate_fast(s, flush) {
  var hash_head;
  /* head of the hash chain */

  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
        /* flush the current block */
      }
    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */


    if (hash_head !== 0
    /*NIL*/
    && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }

    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */

      if (s.match_length <= s.max_lazy_match
      /*max_insert_length*/
      && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        /* string at strstart already in table */

        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/

          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/

          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);

        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif

        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */


function deflate_slow(s, flush) {
  var hash_head;
  /* head of hash chain */

  var bflush;
  /* set if current block must be flushed */

  var max_insert;
  /* Process the input block. */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     */


    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0
    /*NIL*/
    && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
    /*MAX_DIST(s)*/
    ) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096
        /*TOO_FAR*/
        )) {
          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */


    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/

      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */

      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;

      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);

      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));

      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }

      s.strstart++;
      s.lookahead--;

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  } //Assert (flush != Z_NO_FLUSH, "no flush?");


  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));

    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */


function deflate_rle(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  var prev;
  /* byte at distance one to match */

  var scan, strend;
  /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);

      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* See how many times the previous byte repeats */


    s.match_length = 0;

    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];

      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;

        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

        s.match_length = MAX_MATCH - (strend - scan);

        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

    }
    /* Emit match if have run of MIN_MATCH or longer, else emit literal */


    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */


function deflate_huff(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);

      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        break;
        /* flush the current block */
      }
    }
    /* Output a literal byte */


    s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */


function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;
configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored),
/* 0 store only */
new Config(4, 4, 8, 4, deflate_fast),
/* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast),
/* 2 */
new Config(4, 6, 32, 32, deflate_fast),
/* 3 */
new Config(4, 4, 16, 16, deflate_slow),
/* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow),
/* 5 */
new Config(8, 16, 128, 128, deflate_slow),
/* 6 */
new Config(8, 32, 128, 256, deflate_slow),
/* 7 */
new Config(32, 128, 258, 1024, deflate_slow),
/* 8 */
new Config(32, 258, 258, 4096, deflate_slow)
/* 9 max compression */
];
/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */

function lm_init(s) {
  s.window_size = 2 * s.w_size;
  /*** CLEAR_HASH(s); ***/

  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */

  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null;
  /* pointer back to this zlib stream */

  this.status = 0;
  /* as the name implies */

  this.pending_buf = null;
  /* output still pending */

  this.pending_buf_size = 0;
  /* size of pending_buf */

  this.pending_out = 0;
  /* next pending byte to output to the stream */

  this.pending = 0;
  /* nb of bytes in the pending buffer */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.gzhead = null;
  /* gzip header information to write */

  this.gzindex = 0;
  /* where in extra, name, or comment */

  this.method = Z_DEFLATED;
  /* can only be DEFLATED */

  this.last_flush = -1;
  /* value of flush param for previous deflate call */

  this.w_size = 0;
  /* LZ77 window size (32K by default) */

  this.w_bits = 0;
  /* log2(w_size)  (8..16) */

  this.w_mask = 0;
  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;
  /* Heads of the hash chains or NIL. */

  this.ins_h = 0;
  /* hash index of string to be inserted */

  this.hash_size = 0;
  /* number of elements in hash table */

  this.hash_bits = 0;
  /* log2(hash_size) */

  this.hash_mask = 0;
  /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;
  /* length of best match */

  this.prev_match = 0;
  /* previous match */

  this.match_available = 0;
  /* set if previous match exists */

  this.strstart = 0;
  /* start of string to insert */

  this.match_start = 0;
  /* start of matching string */

  this.lookahead = 0;
  /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;

  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;
  /* compression level (1..9) */

  this.strategy = 0;
  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0;
  /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective

  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  /* desc. for literal tree */

  this.d_desc = null;
  /* desc. for distance tree */

  this.bl_desc = null;
  /* desc. for bit length tree */
  //ush bl_count[MAX_BITS+1];

  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

  this.heap = new utils.Buf16(2 * L_CODES + 1);
  /* heap used to build the Huffman trees */

  zero(this.heap);
  this.heap_len = 0;
  /* number of elements in the heap */

  this.heap_max = 0;
  /* element of largest frequency */

  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];

  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;
  /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;
  /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;
  /* bit length of current block with optimal trees */

  this.static_len = 0;
  /* bit length of current block with static trees */

  this.matches = 0;
  /* number of string matches in current block */

  this.insert = 0;
  /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */

  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */
  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;

  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }

  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)

  s.last_flush = Z_NO_FLUSH;

  trees._tr_init(s);

  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);

  if (ret === Z_OK) {
    lm_init(strm.state);
  }

  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }

  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }

  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    /* write gzip wrapper instead */

    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */


  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6;
  /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;

  s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm;
  /* just in case */

  old_flush = s.last_flush;
  s.last_flush = flush;
  /* Write the header */

  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);

      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);

      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);

        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }

        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }

        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }

        header |= level_flags << 6;

        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }

        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        /* Save the adler32 of the preset dictionary: */

        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }

        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  } //#ifdef GZIP


  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              break;
            }
          }

          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }

  if (s.status === NAME_STATE) {
    if (s.gzhead.name
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }

  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }

  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }

      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);

        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  } //#endif

  /* Flush as much pending output as possible */


  if (s.pending !== 0) {
    flush_pending(strm);

    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }
    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */

  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  /* User must not provide more input after the first FINISH: */


  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  /* Start a new block or continue the current one.
   */


  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }

    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }

      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }

    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */
        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */


        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/

          /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }

      flush_pending(strm);

      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR at next call, see above */

        return Z_OK;
      }
    }
  } //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}


  if (flush !== Z_FINISH) {
    return Z_OK;
  }

  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  /* Write the trailer */


  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */

  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */


  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;

  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */


function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  /* when using zlib wrappers, compute Adler-32 for provided dictionary */


  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;
  /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */

  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */

      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);

      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);


    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */


  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);

  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);

    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);

    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }

  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';
/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inffast.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// See state defs from inflate.js

var BAD = 30;
/* got a data error -- remain here until reset */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */

module.exports = function inflate_fast(strm, start) {
  var state;

  var _in;
  /* local strm.input */


  var last;
  /* have enough input while in < last */

  var _out;
  /* local strm.output */


  var beg;
  /* inflate()'s initial strm.output */

  var end;
  /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT

  var dmax;
  /* maximum distance from zlib header */
  //#endif

  var wsize;
  /* window size or zero if not using window */

  var whave;
  /* valid bytes in the window */

  var wnext;
  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools

  var s_window;
  /* allocated sliding window, if wsize != 0 */

  var hold;
  /* local strm.hold */

  var bits;
  /* local strm.bits */

  var lcode;
  /* local strm.lencode */

  var dcode;
  /* local strm.distcode */

  var lmask;
  /* mask for first level of length codes */

  var dmask;
  /* mask for first level of distance codes */

  var here;
  /* retrieved table entry */

  var op;
  /* code bits, operation, extra bits, or */

  /*  window position, window bytes to copy */

  var len;
  /* match length, unused bytes */

  var dist;
  /* match distance */

  var from;
  /* where to copy match from */

  var from_source;
  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */

  state = strm.state; //here = state.here;

  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

  dmax = state.dmax; //#endif

  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24
      /*here.bits*/
      ;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff
      /*here.op*/
      ;

      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff
        /*here.val*/
        ;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff
        /*here.val*/
        ;
        op &= 15;
        /* number of extra bits */

        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }

          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        } //Tracevv((stderr, "inflate:         length %u\n", len));


        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24
          /*here.bits*/
          ;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff
          /*here.op*/
          ;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff
            /*here.val*/
            ;
            op &= 15;
            /* number of extra bits */

            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }

            dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            } //#endif


            hold >>>= op;
            bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

            op = _out - beg;
            /* max distance in output */

            if (dist > op) {
              /* see if copy from window */
              op = dist - op;
              /* distance back in window */

              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                } // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif

              }

              from = 0; // window index

              from_source = s_window;

              if (wnext === 0) {
                /* very common case */
                from += wsize - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;

                if (op < len) {
                  /* some from end of window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = 0;

                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              }

              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }

              if (len) {
                output[_out++] = from_source[from++];

                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist;
              /* copy direct from output */

              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);

              if (len) {
                output[_out++] = output[from++];

                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + (
            /*here.val*/
            hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + (
        /*here.val*/
        hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);
  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  /* update state and return */

  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inflate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");

var adler32 = __webpack_require__("../node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__("../node_modules/pako/lib/zlib/crc32.js");

var inflate_fast = __webpack_require__("../node_modules/pako/lib/zlib/inffast.js");

var inflate_table = __webpack_require__("../node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;

var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* The deflate compression method */

var Z_DEFLATED = 8;
/* STATES ====================================================================*/

/* ===========================================================================*/

var HEAD = 1;
/* i: waiting for magic header */

var FLAGS = 2;
/* i: waiting for method and flags (gzip) */

var TIME = 3;
/* i: waiting for modification time (gzip) */

var OS = 4;
/* i: waiting for extra flags and operating system (gzip) */

var EXLEN = 5;
/* i: waiting for extra length (gzip) */

var EXTRA = 6;
/* i: waiting for extra bytes (gzip) */

var NAME = 7;
/* i: waiting for end of file name (gzip) */

var COMMENT = 8;
/* i: waiting for end of comment (gzip) */

var HCRC = 9;
/* i: waiting for header crc (gzip) */

var DICTID = 10;
/* i: waiting for dictionary check value */

var DICT = 11;
/* waiting for inflateSetDictionary() call */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

var TYPEDO = 13;
/* i: same, but skip check to exit inflate on new block */

var STORED = 14;
/* i: waiting for stored size (length and complement) */

var COPY_ = 15;
/* i/o: same as COPY below, but only first time in */

var COPY = 16;
/* i/o: waiting for input or output to copy stored block */

var TABLE = 17;
/* i: waiting for dynamic block table lengths */

var LENLENS = 18;
/* i: waiting for code length code lengths */

var CODELENS = 19;
/* i: waiting for length/lit and distance code lengths */

var LEN_ = 20;
/* i: same as LEN below, but only first time in */

var LEN = 21;
/* i: waiting for length/lit/eob code */

var LENEXT = 22;
/* i: waiting for length extra bits */

var DIST = 23;
/* i: waiting for distance code */

var DISTEXT = 24;
/* i: waiting for distance extra bits */

var MATCH = 25;
/* o: waiting for output space to copy string */

var LIT = 26;
/* o: waiting for output space to write literal */

var CHECK = 27;
/* i: waiting for 32-bit check value */

var LENGTH = 28;
/* i: waiting for 32-bit length (gzip) */

var DONE = 29;
/* finished check, done -- remain here until reset */

var BAD = 30;
/* got a data error -- remain here until reset */

var MEM = 31;
/* got an inflate() memory error -- remain here until reset */

var SYNC = 32;
/* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0;
  /* current inflate mode */

  this.last = false;
  /* true if processing last block */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.havedict = false;
  /* true if dictionary provided */

  this.flags = 0;
  /* gzip header method and flags (0 if zlib) */

  this.dmax = 0;
  /* zlib header max distance (INFLATE_STRICT) */

  this.check = 0;
  /* protected copy of check value */

  this.total = 0;
  /* protected copy of output count */
  // TODO: may be {}

  this.head = null;
  /* where to save gzip header information */

  /* sliding window */

  this.wbits = 0;
  /* log base 2 of requested window size */

  this.wsize = 0;
  /* window size or zero if not using window */

  this.whave = 0;
  /* valid bytes in the window */

  this.wnext = 0;
  /* window write index */

  this.window = null;
  /* allocated sliding window, if needed */

  /* bit accumulator */

  this.hold = 0;
  /* input bit accumulator */

  this.bits = 0;
  /* number of bits in "in" */

  /* for string and stored block copying */

  this.length = 0;
  /* literal or length of data to copy */

  this.offset = 0;
  /* distance back to copy string from */

  /* for table and code decoding */

  this.extra = 0;
  /* extra bits needed */

  /* fixed and dynamic code tables */

  this.lencode = null;
  /* starting table for length/literal codes */

  this.distcode = null;
  /* starting table for distance codes */

  this.lenbits = 0;
  /* index bits for lencode */

  this.distbits = 0;
  /* index bits for distcode */

  /* dynamic table building */

  this.ncode = 0;
  /* number of code length code lengths */

  this.nlen = 0;
  /* number of length code lengths */

  this.ndist = 0;
  /* number of distance code lengths */

  this.have = 0;
  /* number of code lengths in lens[] */

  this.next = null;
  /* next available space in codes[] */

  this.lens = new utils.Buf16(320);
  /* temporary storage for code lengths */

  this.work = new utils.Buf16(288);
  /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

  this.lendyn = null;
  /* dynamic table for length/literal codes (JS specific) */

  this.distdyn = null;
  /* dynamic table for distance codes (JS specific) */

  this.sane = 0;
  /* if false, allow invalid distance too far */

  this.back = 0;
  /* bits back of last unprocessed length/lit */

  this.was = 0;
  /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = '';
  /*Z_NULL*/

  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }

  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null
  /*Z_NULL*/
  ;
  state.hold = 0;
  state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1; //Tracev((stderr, "inflate: reset\n"));

  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  /* get the state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  /* extract wrap request from windowBits parameter */

  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;

    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  /* set number of window bits, free window if different */


  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }

  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  /* update state and reset the rest of it */


  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  } //strm.msg = Z_NULL;                 /* in case we return an error */


  state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));

  strm.state = state;
  state.window = null
  /*Z_NULL*/
  ;
  ret = inflateReset2(strm, windowBits);

  if (ret !== Z_OK) {
    strm.state = null
    /*Z_NULL*/
    ;
  }

  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */


var virgin = true;
var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    /* literal/length table */

    sym = 0;

    while (sym < 144) {
      state.lens[sym++] = 8;
    }

    while (sym < 256) {
      state.lens[sym++] = 9;
    }

    while (sym < 280) {
      state.lens[sym++] = 7;
    }

    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });
    /* distance table */

    sym = 0;

    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });
    /* do this just once */

    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */


function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  /* if it hasn't been done already, allocate space for the window */

  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils.Buf8(state.wsize);
  }
  /* copy state->wsize or less output bytes into the circular window */


  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;

    if (dist > copy) {
      dist = copy;
    } //zmemcpy(state->window + state->wnext, end - copy, dist);


    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;

    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;

      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }

      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }

  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers

  var next;
  /* next input INDEX */

  var put;
  /* next output INDEX */

  var have, left;
  /* available input and output */

  var hold;
  /* bit buffer */

  var bits;
  /* bits in bit buffer */

  var _in, _out;
  /* save starting available input and output */


  var copy;
  /* number of stored or match bytes to copy */

  var from;
  /* where to copy match bytes from */

  var from_source;
  var here = 0;
  /* current decoding table entry */

  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */

  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

  var len;
  /* length to copy for repeats, bits to drop */

  var ret;
  /* return code */

  var hbuf = new utils.Buf8(4);
  /* buffer for gzip header crc calculation */

  var opts;
  var n; // temporary var for NEED_BITS

  var order =
  /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  /* skip check */
  //--- LOAD() ---


  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits; //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        } //=== NEEDBITS(16);


        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0
          /*crc32(0L, Z_NULL, 0)*/
          ; //=== CRC2(state.check, hold);

          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
          //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          state.mode = FLAGS;
          break;
        }

        state.flags = 0;
        /* expect zlib header */

        if (state.head) {
          state.head.done = false;
        }

        if (!(state.wrap & 1) ||
        /* check if zlib header allowed */
        (((hold & 0xff) <<
        /*BITS(8)*/
        8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }

        if ((hold & 0x0f) !==
        /*BITS(4)*/
        Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        } //--- DROPBITS(4) ---//


        hold >>>= 4;
        bits -= 4; //---//

        len = (hold & 0x0f) +
        /*BITS(4)*/
        8;

        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        break;

      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.flags = hold;

        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }

        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }

        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = TIME;

      /* falls through */

      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.time = hold;
        }

        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0); //===
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = OS;

      /* falls through */

      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = EXLEN;

      /* falls through */

      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length = hold;

          if (state.head) {
            state.head.extra_len = hold;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        } else if (state.head) {
          state.head.extra = null
          /*Z_NULL*/
          ;
        }

        state.mode = EXTRA;

      /* falls through */

      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;

          if (copy > have) {
            copy = have;
          }

          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;

              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }

              utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len); //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }

            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;
            state.length -= copy;
          }

          if (state.length) {
            break inf_leave;
          }
        }

        state.length = 0;
        state.mode = NAME;

      /* falls through */

      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.name_max*/
            ) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }

        state.length = 0;
        state.mode = COMMENT;

      /* falls through */

      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.comm_max*/
            ) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }

        state.mode = HCRC;

      /* falls through */

      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        }

        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }

        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;

      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        strm.adler = state.check = zswap32(hold); //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = DICT;

      /* falls through */

      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          return Z_NEED_DICT;
        }

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = TYPE;

      /* falls through */

      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7; //---//

          state.mode = CHECK;
          break;
        } //=== NEEDBITS(3); */


        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.last = hold & 0x01
        /*BITS(1)*/
        ; //--- DROPBITS(1) ---//

        hold >>>= 1;
        bits -= 1; //---//

        switch (hold & 0x03) {
          /*BITS(2)*/
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;

          case 1:
            /* fixed block */
            fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));

            state.mode = LEN_;
            /* decode codes */

            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2; //---//

              break inf_leave;
            }

            break;

          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;

          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        } //--- DROPBITS(2) ---//


        hold >>>= 2;
        bits -= 2; //---//

        break;

      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7; //---//
        //=== NEEDBITS(32); */

        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }

        state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = COPY_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case COPY_:
        state.mode = COPY;

      /* falls through */

      case COPY:
        copy = state.length;

        if (copy) {
          if (copy > have) {
            copy = have;
          }

          if (copy > left) {
            copy = left;
          }

          if (copy === 0) {
            break inf_leave;
          } //--- zmemcpy(put, next, copy); ---


          utils.arraySet(output, input, next, copy, put); //---//

          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        } //Tracev((stderr, "inflate:       stored end\n"));


        state.mode = TYPE;
        break;

      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.nlen = (hold & 0x1f) +
        /*BITS(5)*/
        257; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ndist = (hold & 0x1f) +
        /*BITS(5)*/
        1; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ncode = (hold & 0x0f) +
        /*BITS(4)*/
        4; //--- DROPBITS(4) ---//

        hold >>>= 4;
        bits -= 4; //---//
        //#ifndef PKZIP_BUG_WORKAROUND

        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        } //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));


        state.have = 0;
        state.mode = LENLENS;

      /* falls through */

      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//

          hold >>>= 3;
          bits -= 3; //---//
        }

        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        } // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table


        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, "inflate:       code lengths ok\n"));


        state.have = 0;
        state.mode = CODELENS;

      /* falls through */

      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            /*BITS(state.lenbits)*/

            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits; //---//

            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }

              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//

              hold >>>= 2;
              bits -= 2; //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//

              hold >>>= 3;
              bits -= 3; //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//

              hold >>>= 7;
              bits -= 7; //---//
            }

            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }

            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }
        /* handle error breaks in while */


        if (state.mode === BAD) {
          break;
        }
        /* check for end-of-block code (better have one) */


        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }
        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */


        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.lenbits = opts.bits; // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6; //state.distcode.copy(state.codes);
        // Switch to use dynamic table

        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.distbits = opts.bits; // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, 'inflate:       codes ok\n'));


        state.mode = LEN_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case LEN_:
        state.mode = LEN;

      /* falls through */

      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          inflate_fast(strm, _out); //--- LOAD() ---

          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits; //---

          if (state.mode === TYPE) {
            state.back = -1;
          }

          break;
        }

        state.back = 0;

        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1];
          /*BITS(state.lenbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;
        state.length = here_val;

        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }

        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }

        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }

        state.extra = here_op & 15;
        state.mode = LENEXT;

      /* falls through */

      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //Tracevv((stderr, "inflate:         length %u\n", state.length));


        state.was = state.length;
        state.mode = DIST;

      /* falls through */

      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1];
          /*BITS(state.distbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;

        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }

        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;

      /* falls through */

      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.offset += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //#ifdef INFLATE_STRICT


        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        } //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


        state.mode = MATCH;

      /* falls through */

      case MATCH:
        if (left === 0) {
          break inf_leave;
        }

        copy = _out - left;

        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;

          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            } // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif

          }

          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }

          if (copy > state.length) {
            copy = state.length;
          }

          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }

        if (copy > left) {
          copy = left;
        }

        left -= copy;
        state.length -= copy;

        do {
          output[put++] = from_source[from++];
        } while (--copy);

        if (state.length === 0) {
          state.mode = LEN;
        }

        break;

      case LIT:
        if (left === 0) {
          break inf_leave;
        }

        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;

      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--; // Use '|' instead of '+' to make sure that result is signed

            hold |= input[next++] << bits;
            bits += 8;
          } //===//


          _out -= left;
          strm.total_out += _out;
          state.total += _out;

          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }

          _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }

        state.mode = LENGTH;

      /* falls through */

      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }

        state.mode = DONE;

      /* falls through */

      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;

      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;

      case MEM:
        return Z_MEM_ERROR;

      case SYNC:
      /* falls through */

      default:
        return Z_STREAM_ERROR;
    }
  } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */
  //--- RESTORE() ---


  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits; //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }

  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;

  if (state.wrap && _out) {
    strm.adler = state.check =
    /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }

  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }

  return ret;
}

function inflateEnd(strm) {
  if (!strm || !strm.state
  /*|| strm->zfree == (free_func)0*/
  ) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;

  if (state.window) {
    state.window = null;
  }

  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;
  /* check state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  /* save header structure */


  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  /* check state */

  if (!strm
  /* == Z_NULL */
  || !strm.state
  /* == Z_NULL */
  ) {
      return Z_STREAM_ERROR;
    }

  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  /* check for correct dictionary identifier */


  if (state.mode === DICT) {
    dictid = 1;
    /* adler32(0, null, 0)*/

    /* dictid = adler32(dictid, dictionary, dictLength); */

    dictid = adler32(dictid, dictionary, dictLength, 0);

    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */


  ret = updatewindow(strm, dictionary, dictLength, dictLength);

  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }

  state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';
/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inftrees.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var lext = [
/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var dbase = [
/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var dext = [
/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits; //here = opts.here; /* table entry for duplication */

  var len = 0;
  /* a code's length in bits */

  var sym = 0;
  /* index of code symbols */

  var min = 0,
      max = 0;
  /* minimum and maximum code lengths */

  var root = 0;
  /* number of index bits for root table */

  var curr = 0;
  /* number of index bits for current table */

  var drop = 0;
  /* code bits to drop for sub-table */

  var left = 0;
  /* number of prefix codes available */

  var used = 0;
  /* code entries in table used */

  var huff = 0;
  /* Huffman code */

  var incr;
  /* for incrementing code, index */

  var fill;
  /* index for replicating entries */

  var low;
  /* low bits for current root entry */

  var mask;
  /* mask for low root bits */

  var next;
  /* next available space in table */

  var base = null;
  /* base value table to use */

  var base_index = 0; //  var shoextra;    /* extra bits table to use */

  var end;
  /* use base and extra for symbol > end */

  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }

  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  /* bound code lengths, force root to be within code lengths */


  root = bits;

  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }

  if (root > max) {
    root = max;
  }

  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;

    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
    /* no symbols, but wait for decoding to report error */
  }

  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }

  if (root < min) {
    root = min;
  }
  /* check for an over-subscribed or incomplete set of lengths */


  left = 1;

  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];

    if (left < 0) {
      return -1;
    }
    /* over-subscribed */

  }

  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
    /* incomplete set */
  }
  /* generate offsets into symbol table for each length for sorting */


  offs[1] = 0;

  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  /* sort symbols by length, by symbol order within each length */


  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8


  if (type === CODES) {
    base = extra = work;
    /* dummy value--not used */

    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }
  /* initialize opts for loop */


  huff = 0;
  /* starting code */

  sym = 0;
  /* starting code symbol */

  len = min;
  /* starting code length */

  next = table_index;
  /* current table to fill in */

  curr = root;
  /* current table index bits */

  drop = 0;
  /* current bits to drop from code for index */

  low = -1;
  /* trigger new sub-table when len > root */

  used = 1 << root;
  /* use root table entries */

  mask = used - 1;
  /* mask for comparing low */

  /* check available table space */

  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  /* process all codes and make table entries */


  for (;;) {
    /* create table entry */
    here_bits = len - drop;

    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      /* end of block */

      here_val = 0;
    }
    /* replicate for those indices with low len bits equal to huff */


    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    /* save offset to next table */

    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    /* backwards increment the len-bit code huff */


    incr = 1 << len - 1;

    while (huff & incr) {
      incr >>= 1;
    }

    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    /* go to next symbol, update count, len */


    sym++;

    if (--count[len] === 0) {
      if (len === max) {
        break;
      }

      len = lens[lens_index + work[sym]];
    }
    /* create new sub-table if needed */


    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }
      /* increment past last table */


      next += min;
      /* here min is 1 << curr */

      /* determine length of next table */

      curr = len - drop;
      left = 1 << curr;

      while (curr + drop < max) {
        left -= count[curr + drop];

        if (left <= 0) {
          break;
        }

        curr++;
        left <<= 1;
      }
      /* check for enough space */


      used += 1 << curr;

      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      /* point entry in root table to sub-table */


      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/

      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */


  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  /* set return parameters */
  //opts.table_index += used;


  opts.bits = root;
  return 0;
};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/messages.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary',

  /* Z_NEED_DICT       2  */
  1: 'stream end',

  /* Z_STREAM_END      1  */
  0: '',

  /* Z_OK              0  */
  '-1': 'file error',

  /* Z_ERRNO         (-1) */
  '-2': 'stream error',

  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',

  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',

  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',

  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version'
  /* Z_VERSION_ERROR (-6) */

};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/trees.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/
//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;


var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */

var Z_BINARY = 0;
var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/*============================================================================*/

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
} // From zutil.h


var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */
// From deflate.h

/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */

var extra_lbits =
/* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var extra_dbits =
/* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var extra_blbits =
/* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */
// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512;
/* see definition of array dist_code below */
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1

var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);

zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  /* static tree or NULL */

  this.extra_bits = extra_bits;
  /* extra bits for each code or NULL */

  this.extra_base = extra_base;
  /* base index for extra_bits */

  this.elems = elems;
  /* max number of elements in the tree */

  this.max_length = max_length;
  /* max bit length for the codes */
  // show if `static_tree` has data or dummy - needed for monomorphic objects

  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  /* the dynamic tree */

  this.max_code = 0;
  /* largest code with non zero frequency */

  this.stat_desc = stat_desc;
  /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */


function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}
/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */


function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]
  /*.Code*/
  , tree[c * 2 + 1]
  /*.Len*/
  );
}
/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */


function bi_reverse(code, len) {
  var res = 0;

  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);

  return res >>> 1;
}
/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */


function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */


function gen_bitlen(s, desc) //    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  /* heap index */

  var n, m;
  /* iterate over the tree elements */

  var bits;
  /* bit length */

  var xbits;
  /* extra bits */

  var f;
  /* frequency */

  var overflow = 0;
  /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */


  tree[s.heap[s.heap_max] * 2 + 1]
  /*.Len*/
  = 0;
  /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]
    /*.Dad*/
    * 2 + 1]
    /*.Len*/
    + 1;

    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }

    tree[n * 2 + 1]
    /*.Len*/
    = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    }
    /* not a leaf node */


    s.bl_count[bits]++;
    xbits = 0;

    if (n >= base) {
      xbits = extra[n - base];
    }

    f = tree[n * 2]
    /*.Freq*/
    ;
    s.opt_len += f * (bits + xbits);

    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]
      /*.Len*/
      + xbits);
    }
  }

  if (overflow === 0) {
    return;
  } // Trace((stderr,"\nbit length overflow\n"));

  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */


  do {
    bits = max_length - 1;

    while (s.bl_count[bits] === 0) {
      bits--;
    }

    s.bl_count[bits]--;
    /* move one leaf down the tree */

    s.bl_count[bits + 1] += 2;
    /* move one overflow item as its brother */

    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */

    overflow -= 2;
  } while (overflow > 0);
  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */


  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];

    while (n !== 0) {
      m = s.heap[--h];

      if (m > max_code) {
        continue;
      }

      if (tree[m * 2 + 1]
      /*.Len*/
      !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]
        /*.Len*/
        ) * tree[m * 2]
        /*.Freq*/
        ;
        tree[m * 2 + 1]
        /*.Len*/
        = bits;
      }

      n--;
    }
  }
}
/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */


function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1);
  /* next code value for each bit length */

  var code = 0;
  /* running code value */

  var bits;
  /* bit index */

  var n;
  /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */

  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1]
    /*.Len*/
    ;

    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */


    tree[n * 2]
    /*.Code*/
    = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}
/* ===========================================================================
 * Initialize the various 'constant' tables.
 */


function tr_static_init() {
  var n;
  /* iterates over tree elements */

  var bits;
  /* bit counter */

  var length;
  /* length value */

  var code;
  /* code value */

  var dist;
  /* distance index */

  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */

  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */

  length = 0;

  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;

    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  } //Assert (length == 256, "tr_static_init: length != 256");

  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */


  _length_code[length - 1] = code;
  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

  dist = 0;

  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;

    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: dist != 256");


  dist >>= 7;
  /* from now on, all distances are divided by 128 */

  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;

    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */


  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;

  while (n <= 143) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }

  while (n <= 255) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 9;
    n++;
    bl_count[9]++;
  }

  while (n <= 279) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 7;
    n++;
    bl_count[7]++;
  }

  while (n <= 287) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */


  gen_codes(static_ltree, L_CODES + 1, bl_count);
  /* The static distance tree is trivial: */

  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]
    /*.Len*/
    = 5;
    static_dtree[n * 2]
    /*.Code*/
    = bi_reverse(n, 5);
  } // Now data ready and we can init static trees


  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
}
/* ===========================================================================
 * Initialize a new block.
 */


function init_block(s) {
  var n;
  /* iterates over tree elements */

  /* Initialize the trees. */

  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2]
    /*.Freq*/
    = 0;
  }

  s.dyn_ltree[END_BLOCK * 2]
  /*.Freq*/
  = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */


function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }

  s.bi_buf = 0;
  s.bi_valid = 0;
}
/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */


function copy_block(s, buf, len, header) //DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);
  /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  } //  while (len--) {
  //    put_byte(s, *buf++);
  //  }


  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */


function smaller(tree, n, m, depth) {
  var _n2 = n * 2;

  var _m2 = m * 2;

  return tree[_n2]
  /*.Freq*/
  < tree[_m2]
  /*.Freq*/
  || tree[_n2]
  /*.Freq*/
  === tree[_m2]
  /*.Freq*/
  && depth[n] <= depth[m];
}
/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */


function pqdownheap(s, tree, k) //    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;
  /* left son of k */

  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */


    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    /* Exchange v with the smallest son */


    s.heap[k] = s.heap[j];
    k = j;
    /* And continue down the tree, setting j to the left son of k */

    j <<= 1;
  }

  s.heap[k] = v;
} // inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */


function compress_block(s, ltree, dtree) //    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;
  /* distance of matched string */

  var lc;
  /* match length or unmatched char (if dist == 0) */

  var lx = 0;
  /* running index in l_buf */

  var code;
  /* the code to send */

  var extra;
  /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree);
        /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        /* send the length code */

        extra = extra_lbits[code];

        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
          /* send the extra length bits */
        }

        dist--;
        /* dist is now the match distance - 1 */

        code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);
        /* send the distance code */

        extra = extra_dbits[code];

        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
          /* send the extra distance bits */
        }
      }
      /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}
/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */


function build_tree(s, desc) //    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  /* iterate over heap elements */

  var max_code = -1;
  /* largest code with non zero frequency */

  var node;
  /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */

  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]
    /*.Freq*/
    !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1]
      /*.Len*/
      = 0;
    }
  }
  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */


  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2]
    /*.Freq*/
    = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]
      /*.Len*/
      ;
    }
    /* node is 0 or 1 so it does not have extra bits */

  }

  desc.max_code = max_code;
  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */

  for (n = s.heap_len >> 1
  /*int /2*/
  ; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */


  node = elems;
  /* next internal node of the tree */

  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */

    /*** pqremove ***/
    n = s.heap[1
    /*SMALLEST*/
    ];
    s.heap[1
    /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
    /***/

    m = s.heap[1
    /*SMALLEST*/
    ];
    /* m = node of next least frequency */

    s.heap[--s.heap_max] = n;
    /* keep the nodes sorted by frequency */

    s.heap[--s.heap_max] = m;
    /* Create a new node father of n and m */

    tree[node * 2]
    /*.Freq*/
    = tree[n * 2]
    /*.Freq*/
    + tree[m * 2]
    /*.Freq*/
    ;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]
    /*.Dad*/
    = tree[m * 2 + 1]
    /*.Dad*/
    = node;
    /* and insert the new node in the heap */

    s.heap[1
    /*SMALLEST*/
    ] = node++;
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1
  /*SMALLEST*/
  ];
  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */

  gen_bitlen(s, desc);
  /* The field len is now set, we can generate the bit codes */

  gen_codes(tree, max_code, s.bl_count);
}
/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */


function scan_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  tree[(max_code + 1) * 2 + 1]
  /*.Len*/
  = 0xffff;
  /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2]
      /*.Freq*/
      += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }

      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */


function send_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  /* tree[max_code+1].Len = -1; */

  /* guard already set */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      } //Assert(count >= 3 && count <= 6, " 3_6?");


      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */


function build_bl_tree(s) {
  var max_blindex;
  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */

  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  /* Build the bit length tree: */

  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */

  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
    /*.Len*/
    !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */


  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}
/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */


function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;
  /* index in bl_order */
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));

  send_bits(s, lcodes - 257, 5);
  /* not +255 as stated in appnote.txt */

  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  /* not -3 as stated in appnote.txt */

  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
    /*.Len*/
    , 3);
  } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


  send_tree(s, s.dyn_ltree, lcodes - 1);
  /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1);
  /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}
/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */


function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;
  /* Check for non-textual ("black-listed") bytes. */

  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_BINARY;
    }
  }
  /* Check for textual ("white-listed") bytes. */


  if (s.dyn_ltree[9 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[10 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[13 * 2]
  /*.Freq*/
  !== 0) {
    return Z_TEXT;
  }

  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_TEXT;
    }
  }
  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */


  return Z_BINARY;
}

var static_init_done = false;
/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */

function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  /* Initialize the first block of the first file: */

  init_block(s);
}
/* ===========================================================================
 * Send a stored block
 */


function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  /* send block type */

  copy_block(s, buf, stored_len, true);
  /* with header */
}
/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */


function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */


function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;
  /* opt_len and static_len in bytes */

  var max_blindex = 0;
  /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */

  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    /* Construct the literal and distance trees */


    build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */

    max_blindex = build_bl_tree(s);
    /* Determine the best encoding. Compute the block lengths in bytes. */

    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5;
    /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */


  init_block(s);

  if (last) {
    bi_windup(s);
  } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));

}
/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */


function _tr_tally(s, dist, lc) //    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */

    dist--;
    /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  } // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif


  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

/***/ }),

/***/ "../node_modules/pako/lib/zlib/zstream.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers

  this.next_in = 0;
  /* number of bytes available at input */

  this.avail_in = 0;
  /* total number of input bytes read so far */

  this.total_in = 0;
  /* next output byte should be put there */

  this.output = null; // JS specific, because we have no pointers

  this.next_out = 0;
  /* remaining free space at output */

  this.avail_out = 0;
  /* total number of bytes output so far */

  this.total_out = 0;
  /* last error message, NULL if no error */

  this.msg = ''
  /*Z_NULL*/
  ;
  /* not visible by applications */

  this.state = null;
  /* best guess about the data type: binary or text */

  this.data_type = 2
  /*Z_UNKNOWN*/
  ;
  /* adler32 value of the uncompressed data */

  this.adler = 0;
}

module.exports = ZStream;

/***/ }),

/***/ "../node_modules/querystring-es3/decode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ "../node_modules/querystring-es3/encode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

/***/ }),

/***/ "../node_modules/querystring-es3/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__("../node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__("../node_modules/querystring-es3/encode.js");

/***/ }),

/***/ "../node_modules/readable-stream/duplex.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_duplex.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
module.exports = Duplex;
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/

/*<replacement>*/


var util = __webpack_require__("../node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

var Readable = __webpack_require__("../node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__("../node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);
forEach(objectKeys(Writable.prototype), function (method) {
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
} // the no-half-open enforcer


function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  global.process.nextTick(this.end.bind(this));
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_passthrough.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
module.exports = PassThrough;

var Transform = __webpack_require__("../node_modules/readable-stream/lib/_stream_transform.js");
/*<replacement>*/


var util = __webpack_require__("../node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_readable.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__("../node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__("../node_modules/buffer/index.js").Buffer;
/*</replacement>*/


Readable.ReadableState = ReadableState;

var EE = __webpack_require__("../node_modules/events/events.js").EventEmitter;
/*<replacement>*/


if (!EE.listenerCount) EE.listenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = __webpack_require__("../node_modules/stream-browserify/index.js");
/*<replacement>*/


var util = __webpack_require__("../node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

var StringDecoder;
/*<replacement>*/

var debug = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");

if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {}; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.

  this.ranOut = false; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__("../node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;
  Stream.call(this);
} // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;

    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);

  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended) onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);
      if (!addToFront) state.reading = false; // if we want the data now, just emit it.

      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
} // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__("../node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 128MB


var MAX_HWM = 0x800000;

function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;

    for (var p = 1; p < 32; p <<= 1) {
      n |= n >> p;
    }

    n++;
  }

  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;
  if (state.objectMode) return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0; // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.

  if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n); // don't have that much.  return null, unless we've ended.

  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else return state.length;
  }

  return n;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;
  if (!util.isNumber(n) || n > 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false;
  } // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.


  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n; // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.

  if (state.length === 0 && !state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);
  if (!util.isNull(ret)) this.emit('data', ret);
  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;

  if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
}

function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) global.process.nextTick(function () {
      emitReadable_(stream);
    });else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    global.process.nextTick(function () {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== global.process.stdout && dest !== global.process.stderr;
  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) global.process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable) {
    debug('onunpipe');

    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata); // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);

    if (false === ret) {
      debug('false write response, pause', src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.


  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error]; // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }

    return this;
  } // try to find the right one.


  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;
  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn); // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.

  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;

    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;

      if (!state.reading) {
        var self = this;
        global.process.nextTick(function () {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on; // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.

Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;

    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }

    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    global.process.nextTick(function () {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;
  var self = this;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length) return;
    var ret = self.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  }); // when we try to consume some more bytes, simply unpause the
  // underlying stream.

  self._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
}; // exposed for testing purposes only.


Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.

function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret; // nothing in the list, definitely empty.

  if (list.length === 0) return null;
  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = new Buffer(n);
      var c = 0;

      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);
        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);
        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();
        c += cpy;
      }
    }
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    global.process.nextTick(function () {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_transform.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
module.exports = Transform;

var Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");
/*<replacement>*/


var util = __webpack_require__("../node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(options, stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
  ts.writechunk = null;
  ts.writecb = null;
  if (!util.isNullOrUndefined(data)) stream.push(data);
  if (cb) cb(er);
  var rs = stream._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(options, this); // when the writable side finishes, then flush out anything remaining.

  var stream = this; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;
  this.once('prefinish', function () {
    if (util.isFunction(this._flush)) this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length) throw new Error('calling transform done when ws.length != 0');
  if (ts.transforming) throw new Error('calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_writable.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.
module.exports = Writable;
/*<replacement>*/

var Buffer = __webpack_require__("../node_modules/buffer/index.js").Buffer;
/*</replacement>*/


Writable.WritableState = WritableState;
/*<replacement>*/

var util = __webpack_require__("../node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

var Stream = __webpack_require__("../node_modules/stream-browserify/index.js");

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {}; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // cast to ints.

  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.buffer = []; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.


  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;
  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};

function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  global.process.nextTick(function () {
    cb(er);
  });
} // If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.


function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    global.process.nextTick(function () {
      cb(er);
    });
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (!util.isFunction(cb)) cb = function cb() {};
  if (state.ended) writeAfterEnd(this, state, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length) clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }

  return chunk;
} // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.


function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) state.buffer.push(new WriteReq(chunk, encoding, cb));else doWrite(stream, state, false, len, chunk, encoding, cb);
  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync) global.process.nextTick(function () {
    state.pendingcb--;
    cb(er);
  });else {
    state.pendingcb--;
    cb(er);
  }
  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      global.process.nextTick(function () {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];

    for (var c = 0; c < state.buffer.length; c++) {
      cbs.push(state.buffer[c].callback);
    } // count the one we are adding, as well.
    // TODO(isaacs) clean this up


    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function (err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    }); // Clear buffer

    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb); // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length) state.buffer = state.buffer.slice(c);else state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk)) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(stream, state) {
  return state.ending && state.length === 0 && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);

  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else prefinish(stream, state);
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) global.process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
}

/***/ }),

/***/ "../node_modules/readable-stream/passthrough.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/readable-stream/lib/_stream_passthrough.js");

/***/ }),

/***/ "../node_modules/readable-stream/readable.js":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = __webpack_require__("../node_modules/stream-browserify/index.js");
exports.Readable = exports;
exports.Writable = __webpack_require__("../node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__("../node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__("../node_modules/readable-stream/lib/_stream_passthrough.js");

if (!global.process.browser && global.process.env.READABLE_STREAM === 'disable') {
  module.exports = __webpack_require__("../node_modules/stream-browserify/index.js");
}

/***/ }),

/***/ "../node_modules/readable-stream/transform.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/readable-stream/lib/_stream_transform.js");

/***/ }),

/***/ "../node_modules/readable-stream/writable.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/readable-stream/lib/_stream_writable.js");

/***/ }),

/***/ "../node_modules/safe-buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__("../node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "../node_modules/schmucklicloud_auth/config.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_ENDPOINT", function() { return API_ENDPOINT; });
var API_ENDPOINT = "https://cloud.schmuckli.net/client_api/v1/auth/";

/***/ }),

/***/ "../node_modules/schmucklicloud_auth/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sCAuth", function() { return sCAuth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sCResult", function() { return sCResult; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../node_modules/schmucklicloud_auth/config.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




class sCAuth {
  /**
  Opens a new schmuckliCloud authentication instance. It can be used to manage then all the data in a defined project.
  @param {String} app_id The APP ID, which was created for a client app in the schmuckliCloud console.
  @param {String} app_secret The APP Secret, which was created for a client app in the schmuckliCloud console.
  */
  constructor(app_id, app_secret) {
    this.appid = app_id;
    this.appsecret = app_secret;
  }
  /*
  --------- Email Password Provider ---------
  */

  /**
   * Adds a new user to the authentication system.
   * @param {string} email The new email
   * @param {string} password The new password
   * @param {string} language A two letter language code (ex. de, en)
   * @returns {boolean}
   */


  registerEmailPassword(email, password, language) {
    var _this = this;

    return _asyncToGenerator(function* () {
      var global_this = _this;
      return new Promise(function (resolve, reject) {
        axios__WEBPACK_IMPORTED_MODULE_1___default()({
          url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"] + "emailpassword.php",
          method: "POST",
          headers: {
            appid: global_this.appid,
            appsecret: global_this.appsecret
          },
          data: {
            email: email,
            password: password,
            lang: language
          }
        }).then(function (response) {
          var data = response.data;

          if (response.status === 200) {
            resolve(new sCResult(data.status, data.message, data.body));
          } else {
            reject(new Error("There was an error while registering the user with email and password. Following error message: " + data.message));
          }
        });
      });
    })();
  }
  /**
   * Authorizes the user with email and password. In the body you will find the session token,
   * @param {string} email The email of the user
   * @param {string} password The password of the user
   * @returns {sCResult} If it was successful, it will provide the session token in the body. Save it somewhere save on the client.
   */


  authorizeEmailPassword(email, password) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var global_this = _this2;
      return new Promise(function (resolve, reject) {
        axios__WEBPACK_IMPORTED_MODULE_1___default()({
          url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"] + "emailpassword.php",
          method: "PUT",
          headers: {
            appid: global_this.appid,
            appsecret: global_this.appsecret
          },
          data: {
            email: email,
            password: password
          }
        }).then(function (response) {
          var data = response.data;

          if (response.status === 200) {
            resolve(new sCResult(data.status, data.message, data.body));
          } else {
            reject(new Error("There was an error while authorizing the user with email and password. Following error message: " + data.message));
          }
        });
      });
    })();
  }
  /**
   * If the user has forgottten his password, just provide the email and it will send an email with a password change link.
   * @param {string} email The email from the account (ex. EmailPassword or any other provider)
   * @returns {sCResult}
   */


  requestResetPassword(email) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      var global_this = _this3;
      return new Promise(function (resolve, reject) {
        axios__WEBPACK_IMPORTED_MODULE_1___default()({
          url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"],
          method: "PUT",
          headers: {
            appid: global_this.appid,
            appsecret: global_this.appsecret
          },
          data: {
            function: "request_reset_password",
            email: email
          }
        }).then(function (response) {
          var data = response.data;

          if (response.status === 200) {
            resolve(new sCResult(data.status, data.message, data.body));
          } else {
            reject(new Error("There was an error while requesting for a new password. Following error message: " + data.message));
          }
        });
      });
    })();
  }
  /**
   * Updates the password for the user, after he has clicked the link in the received mail.
   * @param {string} reset_token The reset token, provided from the sent email to the user
   * @param {string} password The new password for the user
   */


  updateResetPassword(reset_token, password) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      var global_this = _this4;
      return new Promise(function (resolve, reject) {
        axios__WEBPACK_IMPORTED_MODULE_1___default()({
          url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"],
          method: "PUT",
          headers: {
            appid: global_this.appid,
            appsecret: global_this.appsecret
          },
          data: {
            function: "update_reset_password",
            token: reset_token,
            password: password
          }
        }).then(function (response) {
          var data = response.data;

          if (response.status === 200) {
            resolve(new sCResult(data.status, data.message, data.body));
          } else {
            reject(new Error("There was an error while updating the password. Following error message: " + data.message));
          }
        });
      });
    })();
  }
  /**
   * Call this function, if the user has clicked on the activation link in the welcome email.
   * @param {string} token The token, which was given through the parameter in the email link.
   * @returns {sCResult} If it was successful, then it will return a confirmation.
   */


  activateUser(token) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      var global_this = _this5;
      return new Promise(function (resolve, reject) {
        axios__WEBPACK_IMPORTED_MODULE_1___default()({
          url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"],
          method: "PUT",
          headers: {
            appid: global_this.appid,
            appsecret: global_this.appsecret
          },
          data: {
            function: "activate_account",
            token: token
          }
        }).then(function (response) {
          var data = response.data;

          if (response.status === 200) {
            resolve(new sCResult(data.status, data.message, data.body));
          } else {
            reject(new Error("There was an error while activating the user account. Following error message: " + data.message));
          }
        });
      });
    })();
  }

}
/*
Result object for filtering the
*/


class sCResult {
  constructor(status_code, message, body) {
    this.status_code = status_code;
    this.message = message;
    this.data = body;
  }
  /**
   * Returns true, if the request was successfully.
   * @returns {boolean}
   */


  get isOK() {
    return this.status_code >= 200 && this.status_code <= 299 ? true : false;
  }

}



/***/ }),

/***/ "../node_modules/schmucklicloud_storage/config.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_ENDPOINT", function() { return API_ENDPOINT; });
var API_ENDPOINT = "https://cloud.schmuckli.net/client_api/v1/data/";

/***/ }),

/***/ "../node_modules/schmucklicloud_storage/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sCStorage", function() { return sCStorage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sCResult", function() { return sCResult; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../node_modules/schmucklicloud_storage/config.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);


class sCStorage {
  /**
  Opens a new schmuckliCloud storage instance. It can be used to manage then all the data in a defined project.
  @param {String} app_id The APP ID, which was created for a client app in the schmuckliCloud console.
  @param {String} app_secret The APP Secret, which was created for a client app in the schmuckliCloud console.
  */
  constructor(app_id, app_secret) {
    this.appid = app_id;
    this.appsecret = app_secret;
  }
  /**
  Set the dataset, which should be used for the further data operations.
  @param {String} dataset_name The name of the dataset (Do not use the id)
  */


  setDataset(dataset_name) {
    this.dataset = dataset_name;
  }
  /**
   * Binds the authentication token to the storage object, to use the protected dataset, reserved for the user.
   * @param {string} auth_token The authentication session token from the auth library.
   * @param {boolean} not_reset By default, it will reset the dataset. If you want to use the authentication dataset, you must provide a empty dataset string.
   */


  setAuthToken(auth_token, not_reset) {
    this.auth_token = auth_token;

    if (not_reset === false || not_reset === undefined) {
      this.dataset = "";
    }
  }
  /**
  Set the bucket id which later should be used to manage data.
  @param {Number} bucket_id The number of the bucket id
  */


  setBucket(bucket_id) {
    this.bucket_id = bucket_id;
  }
  /**
  This method lets you retrieve all rows from a container.
  @param {String} container_name The container name, created via the schmuckliCloud console
  @param {String} sorting Sort the entries ascending ('asc' by default) or descending ('desc').
  @param {Number} start Define a start index.
  @param {Number} limit Define a maximum of showing results.
  @return {Promise} The function returns you a promise. You can use the 'then' method, to wait for it. Afterwards you get the result.
  */


  getAll(container_name, sorting, start, limit) {
    var global_this = this;
    return new Promise(function (resolve, reject) {
      //Check the properties before sending to the API
      if (container_name === undefined || container_name === "") {
        reject(new Error("Please define a container."));
      }

      if (!sorting) {
        if (sorting !== "asc" && sorting !== "desc") {
          console.warn("schmuckliCloud SDK: The sorting is not declared correclty. Please use 'asc' (default) or 'desc' to sort the data.");
        }
      } else {
        sorting = "";
      }

      if (start === undefined) {
        start = "";
      }

      if (limit === undefined) {
        limit = "";
      }

      axios__WEBPACK_IMPORTED_MODULE_1___default.a.get(_config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"] + "?bucket=" + global_this.bucket_id + "&dataset=" + encodeURI(global_this.dataset) + "&container=" + container_name + "&order=" + sorting + "&start=" + start + "&limit=" + limit, {
        headers: {
          appid: global_this.appid,
          appsecret: global_this.appsecret,
          authtoken: global_this.auth_token
        }
      }).then(function (result) {
        if (result.status === 200) {
          var result = new sCResult(result.data.status, result.data.message, result.data.body);
          resolve(result);
        } else {
          reject(new Error("There was a problem with the API endpoint."));
        }
      });
    });
  }
  /**
  This method lets you retrieve data with filters.
  @param {String} container_name The container name, created via the schmuckliCloud console
  @param {Array} filter A filter is an array, defining which entries should be displayed.
  @param {String} sorting Sort the entries ascending ('asc' by default) or descending ('desc').
  @param {Number} start Define a start index.
  @param {Number} limit Define a maximum of showing results.
  @return {Promise} The function returns you a promise. You can use the 'then' method, to wait for it.
  */


  get(container_name, filter, sorting, start, limit) {
    var global_this = this;
    return new Promise(function (resolve, reject) {
      //Check the properties before sending to the API
      if (container_name === undefined || container_name === "") {
        reject(new Error("Please define a container."));
      }

      if (filter === undefined || filter == 0) {
        reject(new Error("Please define at least one condition. If you want to show all entries, please use the method 'getAll'"));
      }

      if (!(filter instanceof Array)) {
        reject(new Error("Please provide an array containing the conditions."));
      }

      var encodedFilter = encodeURI(JSON.stringify(filter));

      if (!sorting) {
        if (sorting !== "asc" && sorting !== "desc") {
          console.warn("schmuckliCloud SDK: The sorting is not declared correclty. Please use 'asc' (default) or 'desc' to sort the data.");
        }
      } else {
        sorting = "";
      }

      if (start === undefined) {
        start = "";
      }

      if (limit === undefined) {
        limit = "";
      }

      axios__WEBPACK_IMPORTED_MODULE_1___default.a.get(_config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"] + "?bucket=" + global_this.bucket_id + "&dataset=" + encodeURI(global_this.dataset) + "&container=" + encodeURI(container_name) + "&filter=" + encodedFilter + "&order=" + sorting + "&start=" + start + "&limit=" + limit, {
        headers: {
          appid: global_this.appid,
          appsecret: global_this.appsecret,
          authtoken: global_this.auth_token
        }
      }).then(function (result) {
        if (result.status === 200) {
          var result = new sCResult(result.data.status, result.data.message, result.data.body);
          resolve(result);
        } else {
          reject(new Error("There was a problem with the API endpoint. Following error message was sent: " + result.data.message));
        }
      });
    });
  }
  /**
  This methdod can add new rows to you container in the previous set dataset.
  @param {String} container_name The container name, created via the schmuckliCloud console
  @param {String} data A dataobject with a key-value pair. The key represents the columns defined in the schmuckliCloud console.
  @return {Promise} The function returns you a promise. You can use the 'then' method, to wait for it. Afterwards you get a true (when everything was fine) or an error object.
  */


  insert(container_name, data) {
    var global_this = this;
    return new Promise(function (resolve, reject) {
      //Check the properties before sending to the API
      if (container_name === undefined || container_name === "") {
        reject(new Error("Please define a container."));
      }

      var final_data = "{}";

      if (data === undefined || data === {}) {
        reject(new Error("Please provide a data object."));
      } else {
        final_data = JSON.stringify(data);
      }

      axios__WEBPACK_IMPORTED_MODULE_1___default()({
        url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"],
        method: "POST",
        headers: {
          appid: global_this.appid,
          appsecret: global_this.appsecret,
          authtoken: global_this.auth_token
        },
        data: {
          bucket: global_this.bucket_id,
          dataset: encodeURI(global_this.dataset),
          container: encodeURI(container_name),
          data: final_data
        }
      }).then(function (response) {
        var data = response.data;

        if (response.status === 200) {
          resolve(new sCResult(data.status, data.message, data.body));
        } else {
          reject(new Error("There was an error while inserting data. Following error message: " + data.message));
        }
      });
    });
  }
  /**
  This method updates a specific row in a container
  @param {String} container_name Define a container name, which should be updated.
  @param {Number} row_id Define a row id which should be updated
  @param {Object} data Define the data object in a key-value pair
  @return {Promise} The function returns you a promise. You can use the 'then' method, to wait for it. Afterwards you get a true (when everything was fine) or an error object.
  */


  update(container_name, row_id, data) {
    var global_this = this;
    return new Promise(function (resolve, reject) {
      //Check the properties before sending to the API
      if (container_name === undefined || container_name === "") {
        reject(new Error("Please define a container."));
      }

      if (row_id === undefined || isNaN(row_id)) {
        //Check if the value is a number
        reject(new Error("Please provide a row id and make sure it is a number."));
      }

      if (data === undefined || data === [] || data === {} || data === "") {
        reject(new Error("Please provide a data array, with data which should be updated."));
      } else {
        data = JSON.stringify(data);
      }

      axios__WEBPACK_IMPORTED_MODULE_1___default()({
        url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"],
        method: "PUT",
        headers: {
          appid: global_this.appid,
          appsecret: global_this.appsecret,
          authtoken: global_this.auth_token
        },
        data: {
          bucket: global_this.bucket_id,
          dataset: encodeURI(global_this.dataset),
          container: encodeURI(container_name),
          row: row_id,
          data: data
        }
      }).then(function (response) {
        var data = response.data;

        if (response.status === 200) {
          resolve(new sCResult(data.status, data.message, data.body));
        } else {
          reject(new Error("There was an error while updating the data. Following error message: " + data.message));
        }
      });
    });
  }
  /**
  This method deletes a specific row in a container or can just delete a column in a specific row.
  @param {String} container_name Define the container name, where the deletion process should take place
  @param {Number} row_id Define a row id, which can be retrieved by the 'get' or 'getAll' method.
  @param {String} column Define a column name, when just this data in this specific column should be deleted.
  @return {Promise} Returns a promise. Once it has finished the deletion process you can fetch the result in the first parameter.
  */


  delete(container_name, row_id, column) {
    var global_this = this;
    return new Promise(function (resolve, reject) {
      //Check the properties before sending to the API
      if (container_name === undefined || container_name === "") {
        reject(new Error("Please define a container."));
      }

      if (row_id === undefined || isNaN(row_id)) {
        //Check if the value is a number
        reject(new Error("Please provide a row id and make sure it is a number."));
      }

      axios__WEBPACK_IMPORTED_MODULE_1___default()({
        url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"],
        method: "DELETE",
        headers: {
          appid: global_this.appid,
          appsecret: global_this.appsecret,
          authtoken: global_this.auth_token
        },
        data: {
          bucket: global_this.bucket_id,
          dataset: encodeURI(global_this.dataset),
          container: encodeURI(container_name),
          row: row_id,
          col: column
        }
      }).then(function (response) {
        var data = response.data;

        if (response.status === 200) {
          resolve(new sCResult(data.status, data.message, data.body));
        } else {
          reject(new Error("There was an error while deleting the data. Following error message was received: " + data.message));
        }
      });
    });
  }

  metadata(container_name) {
    var global_this = this;
    return new Promise(function (resolve, reject) {
      //Check the properties before sending to the API
      if (container_name === undefined || container_name === "") {
        reject(new Error("Please define a container."));
      }

      axios__WEBPACK_IMPORTED_MODULE_1___default()({
        url: _config__WEBPACK_IMPORTED_MODULE_0__["API_ENDPOINT"] + "metadata.php",
        method: "GET",
        headers: {
          appid: global_this.appid,
          appsecret: global_this.appsecret,
          authtoken: global_this.auth_token
        },
        params: {
          bucket: global_this.bucket_id,
          container: encodeURI(container_name)
        }
      }).then(function (response) {
        var data = response.data;

        if (response.status === 200) {
          resolve(new sCResult(data.status, data.message, data.body));
        } else {
          reject(new Error("There was an error while getting the metadata. Following error message was received: " + data.message));
        }
      });
    });
  }

}
/*
Result object for filtering the
*/

class sCResult {
  constructor(status_code, message, body) {
    this.status_code = status_code;
    this.message = message;
    this.data = body;
  }

  get isOK() {
    return this.status_code >= 200 && this.status_code <= 299 ? true : false;
  }

}

/***/ }),

/***/ "../node_modules/stream-browserify/index.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__("../node_modules/events/events.js").EventEmitter;

var inherits = __webpack_require__("../node_modules/inherits/inherits.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__("../node_modules/readable-stream/readable.js");
Stream.Writable = __webpack_require__("../node_modules/readable-stream/writable.js");
Stream.Duplex = __webpack_require__("../node_modules/readable-stream/duplex.js");
Stream.Transform = __webpack_require__("../node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__("../node_modules/readable-stream/passthrough.js"); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),

/***/ "../node_modules/tty-browserify/index.js":
/***/ (function(module, exports) {

exports.isatty = function () {
  return false;
};

function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}

exports.ReadStream = ReadStream;

function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}

exports.WriteStream = WriteStream;

/***/ }),

/***/ "../node_modules/url/url.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var punycode = __webpack_require__("../node_modules/node-libs-browser/node_modules/punycode/punycode.js");

var util = __webpack_require__("../node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__("../node_modules/querystring-es3/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift())) {
        ;
      }

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "../node_modules/url/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy9odHRwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbGliL2JpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9mb2xsb3ctcmVkaXJlY3RzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaHR0cHMtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9uZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NjaG11Y2tsaWNsb3VkX2F1dGgvY29uZmlnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2NobXVja2xpY2xvdWRfYXV0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NjaG11Y2tsaWNsb3VkX3N0b3JhZ2UvY29uZmlnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2NobXVja2xpY2xvdWRfc3RvcmFnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdHR5LWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiXSwibmFtZXMiOlsiY29tcGFyZSIsImEiLCJiIiwieCIsImxlbmd0aCIsInkiLCJpIiwibGVuIiwiTWF0aCIsIm1pbiIsImlzQnVmZmVyIiwiZ2xvYmFsIiwiQnVmZmVyIiwiX2lzQnVmZmVyIiwidXRpbCIsInJlcXVpcmUiLCJoYXNPd24iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInBTbGljZSIsIkFycmF5Iiwic2xpY2UiLCJmdW5jdGlvbnNIYXZlTmFtZXMiLCJmb28iLCJuYW1lIiwicFRvU3RyaW5nIiwib2JqIiwidG9TdHJpbmciLCJjYWxsIiwiaXNWaWV3IiwiYXJyYnVmIiwiQXJyYXlCdWZmZXIiLCJEYXRhVmlldyIsImJ1ZmZlciIsImFzc2VydCIsIm1vZHVsZSIsImV4cG9ydHMiLCJvayIsInJlZ2V4IiwiZ2V0TmFtZSIsImZ1bmMiLCJpc0Z1bmN0aW9uIiwic3RyIiwibWF0Y2giLCJBc3NlcnRpb25FcnJvciIsIm9wdGlvbnMiLCJhY3R1YWwiLCJleHBlY3RlZCIsIm9wZXJhdG9yIiwibWVzc2FnZSIsImdlbmVyYXRlZE1lc3NhZ2UiLCJnZXRNZXNzYWdlIiwic3RhY2tTdGFydEZ1bmN0aW9uIiwiZmFpbCIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJlcnIiLCJzdGFjayIsIm91dCIsImZuX25hbWUiLCJpZHgiLCJpbmRleE9mIiwibmV4dF9saW5lIiwic3Vic3RyaW5nIiwiaW5oZXJpdHMiLCJ0cnVuY2F0ZSIsInMiLCJuIiwiaW5zcGVjdCIsInNvbWV0aGluZyIsInJhd25hbWUiLCJzZWxmIiwidmFsdWUiLCJlcXVhbCIsIm5vdEVxdWFsIiwiZGVlcEVxdWFsIiwiX2RlZXBFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsInN0cmljdCIsIm1lbW9zIiwiaXNEYXRlIiwiZ2V0VGltZSIsImlzUmVnRXhwIiwic291cmNlIiwibXVsdGlsaW5lIiwibGFzdEluZGV4IiwiaWdub3JlQ2FzZSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQ4QXJyYXkiLCJhY3R1YWxJbmRleCIsInB1c2giLCJvYmpFcXVpdiIsImlzQXJndW1lbnRzIiwib2JqZWN0IiwiYWN0dWFsVmlzaXRlZE9iamVjdHMiLCJ1bmRlZmluZWQiLCJpc1ByaW1pdGl2ZSIsImdldFByb3RvdHlwZU9mIiwiYUlzQXJncyIsImJJc0FyZ3MiLCJrYSIsIm9iamVjdEtleXMiLCJrYiIsImtleSIsInNvcnQiLCJub3REZWVwRXF1YWwiLCJub3REZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3RFcXVhbCIsIm5vdFN0cmljdEVxdWFsIiwiZXhwZWN0ZWRFeGNlcHRpb24iLCJ0ZXN0IiwiZSIsImlzUHJvdG90eXBlT2YiLCJfdHJ5QmxvY2siLCJibG9jayIsImVycm9yIiwiX3Rocm93cyIsInNob3VsZFRocm93IiwiVHlwZUVycm9yIiwidXNlclByb3ZpZGVkTWVzc2FnZSIsImlzVW53YW50ZWRFeGNlcHRpb24iLCJpc0Vycm9yIiwiaXNVbmV4cGVjdGVkRXhjZXB0aW9uIiwidGhyb3dzIiwiZG9lc05vdFRocm93IiwiaWZFcnJvciIsImtleXMiLCJ1dGlscyIsInNldHRsZSIsImJ1aWxkVVJMIiwiaHR0cCIsImh0dHBzIiwiaHR0cEZvbGxvdyIsImh0dHBzRm9sbG93IiwidXJsIiwiemxpYiIsInBrZyIsImNyZWF0ZUVycm9yIiwiZW5oYW5jZUVycm9yIiwiaXNIdHRwcyIsImh0dHBBZGFwdGVyIiwiY29uZmlnIiwiUHJvbWlzZSIsImRpc3BhdGNoSHR0cFJlcXVlc3QiLCJyZXNvbHZlUHJvbWlzZSIsInJlamVjdFByb21pc2UiLCJ0aW1lciIsInJlc29sdmUiLCJjbGVhclRpbWVvdXQiLCJyZWplY3QiLCJkYXRhIiwiaGVhZGVycyIsInZlcnNpb24iLCJpc1N0cmVhbSIsImlzQXJyYXlCdWZmZXIiLCJmcm9tIiwiaXNTdHJpbmciLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInBhcnNlZCIsInBhcnNlIiwicHJvdG9jb2wiLCJ1cmxBdXRoIiwic3BsaXQiLCJ1cmxVc2VybmFtZSIsInVybFBhc3N3b3JkIiwiQXV0aG9yaXphdGlvbiIsImlzSHR0cHNSZXF1ZXN0IiwiYWdlbnQiLCJodHRwc0FnZW50IiwiaHR0cEFnZW50IiwicGF0aCIsInBhcmFtcyIsInBhcmFtc1NlcmlhbGl6ZXIiLCJyZXBsYWNlIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJzb2NrZXRQYXRoIiwiaG9zdG5hbWUiLCJwb3J0IiwicHJveHkiLCJwcm94eUVudiIsInByb3h5VXJsIiwicHJvY2VzcyIsImVudiIsInBhcnNlZFByb3h5VXJsIiwibm9Qcm94eUVudiIsIm5vX3Byb3h5IiwiTk9fUFJPWFkiLCJzaG91bGRQcm94eSIsIm5vUHJveHkiLCJtYXAiLCJ0cmltIiwic29tZSIsInByb3h5TWF0Y2giLCJwcm94eUVsZW1lbnQiLCJzdWJzdHIiLCJob3N0IiwicHJveHlVcmxBdXRoIiwiYmFzZTY0IiwidHJhbnNwb3J0IiwiaXNIdHRwc1Byb3h5IiwibWF4UmVkaXJlY3RzIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJyZXEiLCJyZXF1ZXN0IiwiaGFuZGxlUmVzcG9uc2UiLCJyZXMiLCJhYm9ydGVkIiwic3RyZWFtIiwic3RhdHVzQ29kZSIsInBpcGUiLCJjcmVhdGVVbnppcCIsImxhc3RSZXF1ZXN0IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwic3RhdHVzTWVzc2FnZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlQnVmZmVyIiwib24iLCJoYW5kbGVTdHJlYW1EYXRhIiwiY2h1bmsiLCJjb25jYXQiLCJkZXN0cm95IiwiaGFuZGxlU3RyZWFtRXJyb3IiLCJoYW5kbGVTdHJlYW1FbmQiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZUVuY29kaW5nIiwiaGFuZGxlUmVxdWVzdEVycm9yIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVSZXF1ZXN0VGltZW91dCIsImFib3J0IiwiY2FuY2VsVG9rZW4iLCJwcm9taXNlIiwidGhlbiIsIm9uQ2FuY2VsZWQiLCJjYW5jZWwiLCJlbmQiLCJwYXJzZUhlYWRlcnMiLCJpc1VSTFNhbWVPcmlnaW4iLCJ4aHJBZGFwdGVyIiwiZGlzcGF0Y2hYaHJSZXF1ZXN0IiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsImlzRm9ybURhdGEiLCJYTUxIdHRwUmVxdWVzdCIsImJ0b2EiLCJvcGVuIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaGFuZGxlTG9hZCIsInJlYWR5U3RhdGUiLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVGV4dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsImNvb2tpZXMiLCJ4c3JmVmFsdWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ4c3JmQ29va2llTmFtZSIsInJlYWQiLCJ4c3JmSGVhZGVyTmFtZSIsImZvckVhY2giLCJzZXRSZXF1ZXN0SGVhZGVyIiwidmFsIiwidG9Mb3dlckNhc2UiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJhZGRFdmVudExpc3RlbmVyIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsInNlbmQiLCJiaW5kIiwiQXhpb3MiLCJtZXJnZUNvbmZpZyIsImRlZmF1bHRzIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiY29udGV4dCIsImluc3RhbmNlIiwiZXh0ZW5kIiwiYXhpb3MiLCJjcmVhdGUiLCJpbnN0YW5jZUNvbmZpZyIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJhbGwiLCJwcm9taXNlcyIsInNwcmVhZCIsImRlZmF1bHQiLCJfX0NBTkNFTF9fIiwiZXhlY3V0b3IiLCJwcm9taXNlRXhlY3V0b3IiLCJ0b2tlbiIsInJlYXNvbiIsInRocm93SWZSZXF1ZXN0ZWQiLCJjIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaW50ZXJjZXB0b3JzIiwiYXJndW1lbnRzIiwiY2hhaW4iLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwidW5zaGlmdCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwic2hpZnQiLCJnZXRVcmkiLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwibWVyZ2UiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJoYW5kbGVycyIsInVzZSIsImVqZWN0IiwiaWQiLCJmbiIsImZvckVhY2hIYW5kbGVyIiwiaCIsImNvZGUiLCJ0cmFuc2Zvcm1EYXRhIiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsImJhc2VVUkwiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwiY29tbW9uIiwiY2xlYW5IZWFkZXJDb25maWciLCJhZGFwdGVyIiwib25BZGFwdGVyUmVzb2x1dGlvbiIsInRyYW5zZm9ybVJlc3BvbnNlIiwib25BZGFwdGVyUmVqZWN0aW9uIiwiaXNBeGlvc0Vycm9yIiwidG9KU09OIiwiZGVzY3JpcHRpb24iLCJudW1iZXIiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJjb25maWcxIiwiY29uZmlnMiIsInZhbHVlRnJvbUNvbmZpZzIiLCJwcm9wIiwibWVyZ2VEZWVwUHJvcGVydGllcyIsImlzT2JqZWN0IiwiZGVlcE1lcmdlIiwiZGVmYXVsdFRvQ29uZmlnMiIsInZhbGlkYXRlU3RhdHVzIiwiZm5zIiwidHJhbnNmb3JtIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwic2V0Q29udGVudFR5cGVJZlVuc2V0IiwiaXNVbmRlZmluZWQiLCJnZXREZWZhdWx0QWRhcHRlciIsImlzRmlsZSIsImlzQmxvYiIsImlzQXJyYXlCdWZmZXJWaWV3IiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwidGhpc0FyZyIsIndyYXAiLCJhcmdzIiwiYXBwbHkiLCJlbmNvZGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemVkUGFyYW1zIiwicGFydHMiLCJzZXJpYWxpemUiLCJpc0FycmF5IiwicGFyc2VWYWx1ZSIsInYiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJoYXNobWFya0luZGV4IiwicmVsYXRpdmVVUkwiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJpc051bWJlciIsIkRhdGUiLCJ0b0dNVFN0cmluZyIsImRvY3VtZW50IiwiUmVnRXhwIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVtb3ZlIiwibm93Iiwibm9uU3RhbmRhcmRCcm93c2VyRW52IiwibXNpZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVybFBhcnNpbmdOb2RlIiwiY3JlYXRlRWxlbWVudCIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJocmVmIiwic2V0QXR0cmlidXRlIiwic2VhcmNoIiwiaGFzaCIsInBhdGhuYW1lIiwiY2hhckF0Iiwid2luZG93IiwibG9jYXRpb24iLCJyZXF1ZXN0VVJMIiwibm9ybWFsaXplZE5hbWUiLCJwcm9jZXNzSGVhZGVyIiwiaWdub3JlRHVwbGljYXRlT2YiLCJwYXJzZXIiLCJsaW5lIiwiY2FsbGJhY2siLCJhcnIiLCJGb3JtRGF0YSIsInJlc3VsdCIsIlVSTFNlYXJjaFBhcmFtcyIsInByb2R1Y3QiLCJsIiwiYXNzaWduVmFsdWUiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiWnN0cmVhbSIsInpsaWJfZGVmbGF0ZSIsInpsaWJfaW5mbGF0ZSIsImNvbnN0YW50cyIsIk5PTkUiLCJERUZMQVRFIiwiSU5GTEFURSIsIkdaSVAiLCJHVU5aSVAiLCJERUZMQVRFUkFXIiwiSU5GTEFURVJBVyIsIlVOWklQIiwiR1pJUF9IRUFERVJfSUQxIiwiR1pJUF9IRUFERVJfSUQyIiwiWmxpYiIsIm1vZGUiLCJkaWN0aW9uYXJ5IiwiZmx1c2giLCJpbml0X2RvbmUiLCJsZXZlbCIsIm1lbUxldmVsIiwic3RyYXRlZ3kiLCJ3aW5kb3dCaXRzIiwid3JpdGVfaW5fcHJvZ3Jlc3MiLCJwZW5kaW5nX2Nsb3NlIiwiZ3ppcF9pZF9ieXRlc19yZWFkIiwiY2xvc2UiLCJkZWZsYXRlRW5kIiwic3RybSIsImluZmxhdGVFbmQiLCJpbnB1dCIsImluX29mZiIsImluX2xlbiIsIm91dF9vZmYiLCJvdXRfbGVuIiwiX3dyaXRlIiwid3JpdGVTeW5jIiwiYXN5bmMiLCJaX05PX0ZMVVNIIiwiWl9QQVJUSUFMX0ZMVVNIIiwiWl9TWU5DX0ZMVVNIIiwiWl9GVUxMX0ZMVVNIIiwiWl9GSU5JU0giLCJaX0JMT0NLIiwiYWxsb2MiLCJhdmFpbF9pbiIsIm5leHRfaW4iLCJhdmFpbF9vdXQiLCJuZXh0X291dCIsIl9wcm9jZXNzIiwiX2NoZWNrRXJyb3IiLCJfYWZ0ZXJTeW5jIiwibmV4dFRpY2siLCJfYWZ0ZXIiLCJuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlIiwiZGVmbGF0ZSIsImluZmxhdGUiLCJaX05FRURfRElDVCIsImluZmxhdGVTZXREaWN0aW9uYXJ5IiwiWl9PSyIsIlpfREFUQV9FUlJPUiIsIlpfU1RSRUFNX0VORCIsInJlc2V0IiwiWl9CVUZfRVJST1IiLCJfZXJyb3IiLCJtc2ciLCJpbml0IiwiWl9GSUxURVJFRCIsIlpfSFVGRk1BTl9PTkxZIiwiWl9STEUiLCJaX0ZJWEVEIiwiWl9ERUZBVUxUX1NUUkFURUdZIiwiX2luaXQiLCJfc2V0RGljdGlvbmFyeSIsIl9yZXNldCIsImRlZmxhdGVJbml0MiIsIlpfREVGTEFURUQiLCJpbmZsYXRlSW5pdDIiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsImRlZmxhdGVSZXNldCIsImluZmxhdGVSZXNldCIsIlRyYW5zZm9ybSIsImJpbmRpbmciLCJrTWF4TGVuZ3RoIiwia1JhbmdlRXJyb3JNZXNzYWdlIiwiWl9NSU5fV0lORE9XQklUUyIsIlpfTUFYX1dJTkRPV0JJVFMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsIlpfTUlOX0NIVU5LIiwiWl9NQVhfQ0hVTksiLCJJbmZpbml0eSIsIlpfREVGQVVMVF9DSFVOSyIsIlpfTUlOX01FTUxFVkVMIiwiWl9NQVhfTUVNTEVWRUwiLCJaX0RFRkFVTFRfTUVNTEVWRUwiLCJaX01JTl9MRVZFTCIsIlpfTUFYX0xFVkVMIiwiWl9ERUZBVUxUX0xFVkVMIiwiWl9ERUZBVUxUX0NPTVBSRVNTSU9OIiwiYmtleXMiLCJiayIsImJrZXkiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvZGVzIiwiWl9FUlJOTyIsIlpfU1RSRUFNX0VSUk9SIiwiWl9NRU1fRVJST1IiLCJaX1ZFUlNJT05fRVJST1IiLCJja2V5cyIsImNrIiwiY2tleSIsImZyZWV6ZSIsIkRlZmxhdGUiLCJJbmZsYXRlIiwiR3ppcCIsIkd1bnppcCIsIkRlZmxhdGVSYXciLCJJbmZsYXRlUmF3IiwiVW56aXAiLCJjcmVhdGVEZWZsYXRlIiwibyIsImNyZWF0ZUluZmxhdGUiLCJjcmVhdGVEZWZsYXRlUmF3IiwiY3JlYXRlSW5mbGF0ZVJhdyIsImNyZWF0ZUd6aXAiLCJjcmVhdGVHdW56aXAiLCJvcHRzIiwiemxpYkJ1ZmZlciIsImRlZmxhdGVTeW5jIiwiemxpYkJ1ZmZlclN5bmMiLCJnemlwIiwiZ3ppcFN5bmMiLCJkZWZsYXRlUmF3IiwiZGVmbGF0ZVJhd1N5bmMiLCJ1bnppcCIsInVuemlwU3luYyIsImluZmxhdGVTeW5jIiwiZ3VuemlwIiwiZ3VuemlwU3luYyIsImluZmxhdGVSYXciLCJpbmZsYXRlUmF3U3luYyIsImVuZ2luZSIsImJ1ZmZlcnMiLCJucmVhZCIsIm9uRXJyb3IiLCJvbkVuZCIsImZsb3ciLCJvbmNlIiwicmVtb3ZlTGlzdGVuZXIiLCJidWYiLCJSYW5nZUVycm9yIiwiZmx1c2hGbGFnIiwiX2ZpbmlzaEZsdXNoRmxhZyIsIl9wcm9jZXNzQ2h1bmsiLCJpc1ZhbGlkRmx1c2hGbGFnIiwiZmxhZyIsIl90aGlzIiwiX29wdHMiLCJfY2h1bmtTaXplIiwiY2h1bmtTaXplIiwiZmluaXNoRmx1c2giLCJfZmx1c2hGbGFnIiwiX2hhbmRsZSIsIl9oYWRFcnJvciIsImVycm5vIiwiX2Nsb3NlIiwiZW1pdCIsIl9idWZmZXIiLCJhbGxvY1Vuc2FmZSIsIl9vZmZzZXQiLCJfbGV2ZWwiLCJfc3RyYXRlZ3kiLCJnZXQiLCJjb25maWd1cmFibGUiLCJfZmx1c2giLCJfdHJhbnNmb3JtIiwia2luZCIsIl90aGlzMiIsIndzIiwiX3dyaXRhYmxlU3RhdGUiLCJlbmRlZCIsImVuZGluZyIsIm5lZWREcmFpbiIsImVtaXRDbG9zZU5UIiwiZW5jb2RpbmciLCJjYiIsImxhc3QiLCJhdmFpbEluQmVmb3JlIiwiYXZhaWxPdXRCZWZvcmUiLCJpbk9mZiIsImVyIiwiYXZhaWxJbkFmdGVyIiwiYXZhaWxPdXRBZnRlciIsImhhdmUiLCJuZXdSZXEiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwiX19wcm90b19fIiwic3ViYXJyYXkiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJhc3NlcnRTaXplIiwic2l6ZSIsImZpbGwiLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJjb3B5IiwiaXNuYW4iLCJ0eXBlIiwiU3RyaW5nIiwibGlzdCIsInBvcyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJtIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwibWF4IiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiZGlyIiwiaXNOYU4iLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImoiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwib2Zmc2V0IiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VJbnQiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwiX2FyciIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsImZsb29yIiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsInNldCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInNyYyIsImRzdCIsIm9iamVjdFRvU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiZCIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJjaHJvbWUiLCJsb2NhbCIsImxvY2Fsc3RvcmFnZSIsImNvbG9ycyIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiV2Via2l0QXBwZWFyYW5jZSIsImNvbnNvbGUiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwidGFibGUiLCIkMSIsImZvcm1hdHRlcnMiLCJuYW1lc3BhY2UiLCJodW1hbml6ZSIsImRpZmYiLCJjb2xvciIsInNwbGljZSIsImluZGV4IiwibGFzdEMiLCJGdW5jdGlvbiIsIm5hbWVzcGFjZXMiLCJyZW1vdmVJdGVtIiwiZGVidWciLCJyIiwiREVCVUciLCJlbmFibGUiLCJsb2NhbFN0b3JhZ2UiLCJjcmVhdGVEZWJ1ZyIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGVkIiwibmFtZXMiLCJza2lwcyIsInByZXZUaW1lIiwic2VsZWN0Q29sb3IiLCJhYnMiLCJjdXJyIiwibXMiLCJwcmV2IiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwibG9nRm4iLCJ0dHkiLCJpbnNwZWN0T3B0cyIsImZpbHRlciIsInJlZHVjZSIsIl8iLCJrIiwiZmQiLCJERUJVR19GRCIsImRlcHJlY2F0ZSIsInN0ZG91dCIsInN0ZGVyciIsImNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0iLCJCb29sZWFuIiwiaXNhdHR5IiwiTyIsInByZWZpeCIsInRvVVRDU3RyaW5nIiwidHR5X3dyYXAiLCJndWVzc0hhbmRsZVR5cGUiLCJXcml0ZVN0cmVhbSIsIl90eXBlIiwidW5yZWYiLCJmcyIsIlN5bmNXcml0ZVN0cmVhbSIsImF1dG9DbG9zZSIsIm5ldCIsIlNvY2tldCIsInJlYWRhYmxlIiwiX2lzU3RkaW8iLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsInJlY2VpdmVyIiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJzZXRNYXhMaXN0ZW5lcnMiLCIkZ2V0TWF4TGlzdGVuZXJzIiwiZ2V0TWF4TGlzdGVuZXJzIiwiZG9FcnJvciIsImV2ZW50cyIsImhhbmRsZXIiLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwibGlzdGVuZXIiLCJwcmVwZW5kIiwiZXhpc3RpbmciLCJuZXdMaXN0ZW5lciIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJ3cmFwRm4iLCJfb25jZVdyYXAiLCJzdGF0ZSIsIndyYXBwZWQiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwicG9zaXRpb24iLCJvcmlnaW5hbExpc3RlbmVyIiwic3BsaWNlT25lIiwib2ZmIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsInBvcCIsIldyaXRhYmxlIiwiU0FGRV9NRVRIT0RTIiwiR0VUIiwiSEVBRCIsIk9QVElPTlMiLCJUUkFDRSIsImV2ZW50SGFuZGxlcnMiLCJldmVudCIsIl9yZWRpcmVjdGFibGUiLCJSZWRpcmVjdGFibGVSZXF1ZXN0IiwicmVzcG9uc2VDYWxsYmFjayIsIl9vcHRpb25zIiwiX3JlZGlyZWN0Q291bnQiLCJfcmVkaXJlY3RzIiwiX3JlcXVlc3RCb2R5TGVuZ3RoIiwiX3JlcXVlc3RCb2R5QnVmZmVycyIsIl9vbk5hdGl2ZVJlc3BvbnNlIiwiX3Byb2Nlc3NSZXNwb25zZSIsInNlYXJjaFBvcyIsIl9wZXJmb3JtUmVxdWVzdCIsIl9jdXJyZW50UmVxdWVzdCIsImN1cnJlbnRSZXF1ZXN0Iiwic2V0SGVhZGVyIiwicmVtb3ZlSGVhZGVyIiwicHJvcGVydHkiLCJuYXRpdmVQcm90b2NvbCIsIm5hdGl2ZVByb3RvY29scyIsImFnZW50cyIsInNjaGVtZSIsIl9jdXJyZW50VXJsIiwiX2lzUmVkaXJlY3QiLCJ3cml0ZU5leHQiLCJ0cmFja1JlZGlyZWN0cyIsImZvbGxvd1JlZGlyZWN0cyIsImhlYWRlciIsInJlZGlyZWN0VXJsIiwiYXNzaWduIiwicmVzcG9uc2VVcmwiLCJyZWRpcmVjdHMiLCJwcm90b2NvbHMiLCJ3cmFwcGVkUHJvdG9jb2wiLCJ2YWxpZGF0ZVBhcmFtcyIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiTmFOIiwicnQiLCJMTjIiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiY29uc3RydWN0b3IiLCJUZW1wQ3RvciIsImlzU2xvd0J1ZmZlciIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJleGVjIiwicGFyc2VGbG9hdCIsInJvdW5kIiwicGx1cmFsIiwiY2VpbCIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJwdW55Y29kZSIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIm1hcERvbWFpbiIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImRlY29kZSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInQiLCJiYXNlTWludXNUIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwidG9Vbmljb2RlIiwidG9BU0NJSSIsImRlZmluZSIsIl9ub3JtYWxpemVFbmNvZGluZyIsImVuYyIsInJldHJpZWQiLCJub3JtYWxpemVFbmNvZGluZyIsIm5lbmMiLCJTdHJpbmdEZWNvZGVyIiwibmIiLCJ0ZXh0IiwidXRmMTZUZXh0IiwidXRmMTZFbmQiLCJmaWxsTGFzdCIsInV0ZjhGaWxsTGFzdCIsImJhc2U2NFRleHQiLCJiYXNlNjRFbmQiLCJzaW1wbGVXcml0ZSIsInNpbXBsZUVuZCIsImxhc3ROZWVkIiwibGFzdFRvdGFsIiwibGFzdENoYXIiLCJ1dGY4RW5kIiwidXRmOFRleHQiLCJ1dGY4Q2hlY2tCeXRlIiwiYnl0ZSIsInV0ZjhDaGVja0luY29tcGxldGUiLCJ1dGY4Q2hlY2tFeHRyYUJ5dGVzIiwicCIsInRvdGFsIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZm9ybWF0UmVnRXhwIiwiZiIsIm9iamVjdHMiLCJub0RlcHJlY2F0aW9uIiwiZGVwcmVjYXRlZCIsInRocm93RGVwcmVjYXRpb24iLCJ0cmFjZURlcHJlY2F0aW9uIiwidHJhY2UiLCJkZWJ1Z3MiLCJkZWJ1Z0Vudmlyb24iLCJkZWJ1Z2xvZyIsIk5PREVfREVCVUciLCJwaWQiLCJjdHgiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiZGVwdGgiLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJzdHlsZXMiLCJzdHlsZVR5cGUiLCJhcnJheVRvSGFzaCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiZm9ybWF0RXJyb3IiLCJicmFjZXMiLCJmb3JtYXRBcnJheSIsImZvcm1hdFByb3BlcnR5IiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJzaW1wbGUiLCJkZXNjIiwibnVtTGluZXNFc3QiLCJjdXIiLCJhciIsInBhZCIsIm1vbnRocyIsInRpbWVzdGFtcCIsInRpbWUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwiYWRkIiwia0N1c3RvbVByb21pc2lmaWVkU3ltYm9sIiwicHJvbWlzaWZ5Iiwib3JpZ2luYWwiLCJwcm9taXNlUmVzb2x2ZSIsInByb21pc2VSZWplY3QiLCJzZXRQcm90b3R5cGVPZiIsImRlZmluZVByb3BlcnRpZXMiLCJjdXN0b20iLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJuZXdSZWFzb24iLCJjYWxsYmFja2lmeSIsImNhbGxiYWNraWZpZWQiLCJtYXliZUNiIiwicmVqIiwiVFlQRURfT0siLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJfaGFzIiwic291cmNlcyIsInNocmlua0J1ZiIsImZuVHlwZWQiLCJhcnJheVNldCIsImRlc3QiLCJzcmNfb2ZmcyIsImRlc3Rfb2ZmcyIsImZsYXR0ZW5DaHVua3MiLCJjaHVua3MiLCJmblVudHlwZWQiLCJzZXRUeXBlZCIsIkJ1ZjgiLCJCdWYxNiIsIkJ1ZjMyIiwiYWRsZXIzMiIsImFkbGVyIiwiczEiLCJzMiIsIlpfVFJFRVMiLCJaX05PX0NPTVBSRVNTSU9OIiwiWl9CRVNUX1NQRUVEIiwiWl9CRVNUX0NPTVBSRVNTSU9OIiwiWl9CSU5BUlkiLCJaX1RFWFQiLCJaX1VOS05PV04iLCJtYWtlVGFibGUiLCJjcmNUYWJsZSIsImNyYzMyIiwiY3JjIiwidHJlZXMiLCJNQVhfTUVNX0xFVkVMIiwiTUFYX1dCSVRTIiwiREVGX01FTV9MRVZFTCIsIkxFTkdUSF9DT0RFUyIsIkxJVEVSQUxTIiwiTF9DT0RFUyIsIkRfQ09ERVMiLCJCTF9DT0RFUyIsIkhFQVBfU0laRSIsIk1BWF9CSVRTIiwiTUlOX01BVENIIiwiTUFYX01BVENIIiwiTUlOX0xPT0tBSEVBRCIsIlBSRVNFVF9ESUNUIiwiSU5JVF9TVEFURSIsIkVYVFJBX1NUQVRFIiwiTkFNRV9TVEFURSIsIkNPTU1FTlRfU1RBVEUiLCJIQ1JDX1NUQVRFIiwiQlVTWV9TVEFURSIsIkZJTklTSF9TVEFURSIsIkJTX05FRURfTU9SRSIsIkJTX0JMT0NLX0RPTkUiLCJCU19GSU5JU0hfU1RBUlRFRCIsIkJTX0ZJTklTSF9ET05FIiwiT1NfQ09ERSIsImVycm9yQ29kZSIsInJhbmsiLCJ6ZXJvIiwiZmx1c2hfcGVuZGluZyIsInBlbmRpbmciLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmdfb3V0IiwidG90YWxfb3V0IiwiZmx1c2hfYmxvY2tfb25seSIsIl90cl9mbHVzaF9ibG9jayIsImJsb2NrX3N0YXJ0Iiwic3Ryc3RhcnQiLCJwdXRfYnl0ZSIsInB1dFNob3J0TVNCIiwicmVhZF9idWYiLCJ0b3RhbF9pbiIsImxvbmdlc3RfbWF0Y2giLCJjdXJfbWF0Y2giLCJjaGFpbl9sZW5ndGgiLCJtYXhfY2hhaW5fbGVuZ3RoIiwic2NhbiIsImJlc3RfbGVuIiwicHJldl9sZW5ndGgiLCJuaWNlX21hdGNoIiwid19zaXplIiwiX3dpbiIsIndtYXNrIiwid19tYXNrIiwic3RyZW5kIiwic2Nhbl9lbmQxIiwic2Nhbl9lbmQiLCJnb29kX21hdGNoIiwibG9va2FoZWFkIiwibWF0Y2hfc3RhcnQiLCJmaWxsX3dpbmRvdyIsIl93X3NpemUiLCJtb3JlIiwid2luZG93X3NpemUiLCJoYXNoX3NpemUiLCJoZWFkIiwiaW5zZXJ0IiwiaW5zX2giLCJoYXNoX3NoaWZ0IiwiaGFzaF9tYXNrIiwiZGVmbGF0ZV9zdG9yZWQiLCJtYXhfYmxvY2tfc2l6ZSIsInBlbmRpbmdfYnVmX3NpemUiLCJtYXhfc3RhcnQiLCJkZWZsYXRlX2Zhc3QiLCJoYXNoX2hlYWQiLCJiZmx1c2giLCJtYXRjaF9sZW5ndGgiLCJfdHJfdGFsbHkiLCJtYXhfbGF6eV9tYXRjaCIsImxhc3RfbGl0IiwiZGVmbGF0ZV9zbG93IiwibWF4X2luc2VydCIsInByZXZfbWF0Y2giLCJtYXRjaF9hdmFpbGFibGUiLCJkZWZsYXRlX3JsZSIsImRlZmxhdGVfaHVmZiIsIkNvbmZpZyIsImdvb2RfbGVuZ3RoIiwibWF4X2xhenkiLCJuaWNlX2xlbmd0aCIsIm1heF9jaGFpbiIsImNvbmZpZ3VyYXRpb25fdGFibGUiLCJsbV9pbml0IiwiRGVmbGF0ZVN0YXRlIiwiZ3poZWFkIiwiZ3ppbmRleCIsImxhc3RfZmx1c2giLCJ3X2JpdHMiLCJoYXNoX2JpdHMiLCJkeW5fbHRyZWUiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibF9kZXNjIiwiZF9kZXNjIiwiYmxfZGVzYyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbGVuIiwiaGVhcF9tYXgiLCJsX2J1ZiIsImxpdF9idWZzaXplIiwiZF9idWYiLCJvcHRfbGVuIiwic3RhdGljX2xlbiIsIm1hdGNoZXMiLCJiaV9idWYiLCJiaV92YWxpZCIsImRlZmxhdGVSZXNldEtlZXAiLCJkYXRhX3R5cGUiLCJfdHJfaW5pdCIsImRlZmxhdGVTZXRIZWFkZXIiLCJkZWZsYXRlSW5pdCIsIm9sZF9mbHVzaCIsImJlZyIsImhjcmMiLCJjb21tZW50Iiwib3MiLCJsZXZlbF9mbGFncyIsImJzdGF0ZSIsIl90cl9hbGlnbiIsIl90cl9zdG9yZWRfYmxvY2siLCJkaWN0TGVuZ3RoIiwiYXZhaWwiLCJuZXh0IiwidG1wRGljdCIsImRlZmxhdGVJbmZvIiwiQkFEIiwiVFlQRSIsImluZmxhdGVfZmFzdCIsIl9pbiIsIl9vdXQiLCJkbWF4Iiwid3NpemUiLCJ3aGF2ZSIsInduZXh0Iiwic193aW5kb3ciLCJob2xkIiwiYml0cyIsImxjb2RlIiwiZGNvZGUiLCJsbWFzayIsImRtYXNrIiwiaGVyZSIsIm9wIiwiZGlzdCIsImZyb21fc291cmNlIiwibGVuY29kZSIsImRpc3Rjb2RlIiwibGVuYml0cyIsImRpc3RiaXRzIiwidG9wIiwiZG9sZW4iLCJkb2Rpc3QiLCJzYW5lIiwiaW5mbGF0ZV90YWJsZSIsIkNPREVTIiwiTEVOUyIsIkRJU1RTIiwiRkxBR1MiLCJUSU1FIiwiT1MiLCJFWExFTiIsIkVYVFJBIiwiTkFNRSIsIkNPTU1FTlQiLCJIQ1JDIiwiRElDVElEIiwiRElDVCIsIlRZUEVETyIsIlNUT1JFRCIsIkNPUFlfIiwiQ09QWSIsIlRBQkxFIiwiTEVOTEVOUyIsIkNPREVMRU5TIiwiTEVOXyIsIkxFTiIsIkxFTkVYVCIsIkRJU1QiLCJESVNURVhUIiwiTUFUQ0giLCJMSVQiLCJDSEVDSyIsIkxFTkdUSCIsIkRPTkUiLCJNRU0iLCJTWU5DIiwiRU5PVUdIX0xFTlMiLCJFTk9VR0hfRElTVFMiLCJERUZfV0JJVFMiLCJ6c3dhcDMyIiwiSW5mbGF0ZVN0YXRlIiwiaGF2ZWRpY3QiLCJmbGFncyIsImNoZWNrIiwid2JpdHMiLCJuY29kZSIsIm5sZW4iLCJuZGlzdCIsIndvcmsiLCJsZW5keW4iLCJkaXN0ZHluIiwiYmFjayIsIndhcyIsImluZmxhdGVSZXNldEtlZXAiLCJpbmZsYXRlUmVzZXQyIiwiaW5mbGF0ZUluaXQiLCJ2aXJnaW4iLCJsZW5maXgiLCJkaXN0Zml4IiwiZml4ZWR0YWJsZXMiLCJzeW0iLCJ1cGRhdGV3aW5kb3ciLCJwdXQiLCJsZWZ0IiwiaGVyZV9iaXRzIiwiaGVyZV9vcCIsImhlcmVfdmFsIiwibGFzdF9iaXRzIiwibGFzdF9vcCIsImxhc3RfdmFsIiwiaGJ1ZiIsIm9yZGVyIiwiaW5mX2xlYXZlIiwiZG9uZSIsInhmbGFncyIsImV4dHJhX2xlbiIsImluZmxhdGVHZXRIZWFkZXIiLCJkaWN0aWQiLCJpbmZsYXRlSW5mbyIsIk1BWEJJVFMiLCJsYmFzZSIsImxleHQiLCJkYmFzZSIsImRleHQiLCJsZW5zX2luZGV4IiwidGFibGVfaW5kZXgiLCJkcm9wIiwidXNlZCIsImh1ZmYiLCJpbmNyIiwibG93IiwibWFzayIsImJhc2VfaW5kZXgiLCJvZmZzIiwiZXh0cmFfaW5kZXgiLCJTVE9SRURfQkxPQ0siLCJTVEFUSUNfVFJFRVMiLCJEWU5fVFJFRVMiLCJCdWZfc2l6ZSIsIk1BWF9CTF9CSVRTIiwiRU5EX0JMT0NLIiwiUkVQXzNfNiIsIlJFUFpfM18xMCIsIlJFUFpfMTFfMTM4IiwiZXh0cmFfbGJpdHMiLCJleHRyYV9kYml0cyIsImV4dHJhX2JsYml0cyIsImJsX29yZGVyIiwiRElTVF9DT0RFX0xFTiIsInN0YXRpY19sdHJlZSIsInN0YXRpY19kdHJlZSIsIl9kaXN0X2NvZGUiLCJfbGVuZ3RoX2NvZGUiLCJiYXNlX2xlbmd0aCIsImJhc2VfZGlzdCIsIlN0YXRpY1RyZWVEZXNjIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsInN0YXRpY19sX2Rlc2MiLCJzdGF0aWNfZF9kZXNjIiwic3RhdGljX2JsX2Rlc2MiLCJUcmVlRGVzYyIsImR5bl90cmVlIiwic3RhdF9kZXNjIiwibWF4X2NvZGUiLCJkX2NvZGUiLCJwdXRfc2hvcnQiLCJzZW5kX2JpdHMiLCJzZW5kX2NvZGUiLCJ0cmVlIiwiYmlfcmV2ZXJzZSIsImJpX2ZsdXNoIiwiZ2VuX2JpdGxlbiIsInN0cmVlIiwieGJpdHMiLCJvdmVyZmxvdyIsImdlbl9jb2RlcyIsIm5leHRfY29kZSIsInRyX3N0YXRpY19pbml0IiwiaW5pdF9ibG9jayIsImJpX3dpbmR1cCIsImNvcHlfYmxvY2siLCJzbWFsbGVyIiwiX24yIiwiX20yIiwicHFkb3duaGVhcCIsImNvbXByZXNzX2Jsb2NrIiwibHRyZWUiLCJkdHJlZSIsImxjIiwibHgiLCJidWlsZF90cmVlIiwibm9kZSIsInNjYW5fdHJlZSIsInByZXZsZW4iLCJjdXJsZW4iLCJuZXh0bGVuIiwibWF4X2NvdW50IiwibWluX2NvdW50Iiwic2VuZF90cmVlIiwiYnVpbGRfYmxfdHJlZSIsIm1heF9ibGluZGV4Iiwic2VuZF9hbGxfdHJlZXMiLCJsY29kZXMiLCJkY29kZXMiLCJibGNvZGVzIiwiZGV0ZWN0X2RhdGFfdHlwZSIsImJsYWNrX21hc2siLCJzdGF0aWNfaW5pdF9kb25lIiwic3RvcmVkX2xlbiIsIm9wdF9sZW5iIiwic3RhdGljX2xlbmIiLCJaU3RyZWFtIiwicXMiLCJzZXAiLCJlcSIsInJlZ2V4cCIsIm1heEtleXMiLCJrc3RyIiwidnN0ciIsInhzIiwic3RyaW5naWZ5UHJpbWl0aXZlIiwia3MiLCJEdXBsZXgiLCJSZWFkYWJsZSIsImFsbG93SGFsZk9wZW4iLCJvbmVuZCIsIlBhc3NUaHJvdWdoIiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiU3RyZWFtIiwiaHdtIiwiaGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJvYmplY3RNb2RlIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVhZGFibGVPYmplY3RNb2RlIiwiZGVmYXVsdEVuY29kaW5nIiwicmFuT3V0IiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsIl9yZWFkYWJsZVN0YXRlIiwicmVhZGFibGVBZGRDaHVuayIsImFkZFRvRnJvbnQiLCJjaHVua0ludmFsaWQiLCJvbkVvZkNodW5rIiwiZW1pdFJlYWRhYmxlIiwibWF5YmVSZWFkTW9yZSIsIm5lZWRNb3JlRGF0YSIsInNldEVuY29kaW5nIiwiTUFYX0hXTSIsInJvdW5kVXBUb05leHRQb3dlck9mMiIsImhvd011Y2hUb1JlYWQiLCJuT3JpZyIsImVuZFJlYWRhYmxlIiwiZG9SZWFkIiwiX3JlYWQiLCJmcm9tTGlzdCIsImVtaXRSZWFkYWJsZV8iLCJtYXliZVJlYWRNb3JlXyIsInBpcGVPcHRzIiwiZG9FbmQiLCJlbmRGbiIsImNsZWFudXAiLCJvbnVucGlwZSIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZGF0YSIsInBhdXNlIiwidW5waXBlIiwicmVzdW1lIiwiZGVzdHMiLCJldiIsInJlc3VtZVNjaGVkdWxlZCIsInJlc3VtZV8iLCJwYXVzZWQiLCJfZnJvbUxpc3QiLCJzdHJpbmdNb2RlIiwiY3B5IiwiVHJhbnNmb3JtU3RhdGUiLCJhZnRlclRyYW5zZm9ybSIsIm5lZWRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1pbmciLCJ3cml0ZWNiIiwid3JpdGVjaHVuayIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwicnMiLCJ3cml0ZWVuY29kaW5nIiwiV3JpdGFibGVTdGF0ZSIsIldyaXRlUmVxIiwid3JpdGFibGVPYmplY3RNb2RlIiwiZmluaXNoZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJ3cml0aW5nIiwiY29ya2VkIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJ3cml0ZWxlbiIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwid3JpdGVBZnRlckVuZCIsInZhbGlkQ2h1bmsiLCJ2YWxpZCIsIndyaXRlT3JCdWZmZXIiLCJjb3JrIiwidW5jb3JrIiwiY2xlYXJCdWZmZXIiLCJkZWNvZGVDaHVuayIsImRvV3JpdGUiLCJ3cml0ZXYiLCJfd3JpdGV2Iiwib253cml0ZUVycm9yIiwib253cml0ZVN0YXRlVXBkYXRlIiwibmVlZEZpbmlzaCIsImFmdGVyV3JpdGUiLCJvbndyaXRlRHJhaW4iLCJmaW5pc2hNYXliZSIsImNicyIsImVudHJ5IiwiZW5kV3JpdGFibGUiLCJwcmVmaW5pc2giLCJuZWVkIiwiYnJvd3NlciIsIlJFQURBQkxFX1NUUkVBTSIsImNvcHlQcm9wcyIsIlNhZmVCdWZmZXIiLCJBUElfRU5EUE9JTlQiLCJzQ0F1dGgiLCJhcHBfaWQiLCJhcHBfc2VjcmV0IiwiYXBwaWQiLCJhcHBzZWNyZXQiLCJyZWdpc3RlckVtYWlsUGFzc3dvcmQiLCJlbWFpbCIsImxhbmd1YWdlIiwiZ2xvYmFsX3RoaXMiLCJsYW5nIiwic0NSZXN1bHQiLCJib2R5IiwiYXV0aG9yaXplRW1haWxQYXNzd29yZCIsInJlcXVlc3RSZXNldFBhc3N3b3JkIiwiZnVuY3Rpb24iLCJ1cGRhdGVSZXNldFBhc3N3b3JkIiwicmVzZXRfdG9rZW4iLCJhY3RpdmF0ZVVzZXIiLCJzdGF0dXNfY29kZSIsImlzT0siLCJzQ1N0b3JhZ2UiLCJzZXREYXRhc2V0IiwiZGF0YXNldF9uYW1lIiwiZGF0YXNldCIsInNldEF1dGhUb2tlbiIsImF1dGhfdG9rZW4iLCJub3RfcmVzZXQiLCJzZXRCdWNrZXQiLCJidWNrZXRfaWQiLCJnZXRBbGwiLCJjb250YWluZXJfbmFtZSIsInNvcnRpbmciLCJlbmNvZGVVUkkiLCJhdXRodG9rZW4iLCJlbmNvZGVkRmlsdGVyIiwiZmluYWxfZGF0YSIsImJ1Y2tldCIsImNvbnRhaW5lciIsInVwZGF0ZSIsInJvd19pZCIsInJvdyIsImRlbGV0ZSIsImNvbHVtbiIsImNvbCIsIm1ldGFkYXRhIiwiZGlkT25FbmQiLCJSZWFkU3RyZWFtIiwidXJsUGFyc2UiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJ1cmxGb3JtYXQiLCJVcmwiLCJzbGFzaGVzIiwicXVlcnkiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJ1IiwicXVlcnlJbmRleCIsInNwbGl0dGVyIiwidVNwbGl0Iiwic2xhc2hSZWdleCIsInJlc3QiLCJzaW1wbGVQYXRoIiwicHJvdG8iLCJsb3dlclByb3RvIiwiaG9zdEVuZCIsImhlYyIsImF0U2lnbiIsInBhcnNlSG9zdCIsImlwdjZIb3N0bmFtZSIsImhvc3RwYXJ0cyIsInBhcnQiLCJuZXdwYXJ0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJhZSIsImVzYyIsImVzY2FwZSIsInFtIiwicmVsYXRpdmUiLCJyZWwiLCJ0a2V5cyIsInRrIiwidGtleSIsInJrZXlzIiwicmsiLCJya2V5IiwicmVsUGF0aCIsImlzU291cmNlQWJzIiwiaXNSZWxBYnMiLCJtdXN0RW5kQWJzIiwicmVtb3ZlQWxsRG90cyIsInNyY1BhdGgiLCJwc3ljaG90aWMiLCJhdXRoSW5Ib3N0IiwiaGFzVHJhaWxpbmdTbGFzaCIsInVwIiwiaXNBYnNvbHV0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsOEMsQ0FFQTtBQUNBOztBQUVBOzs7Ozs7O0FBTUEsU0FBU0EsT0FBVCxDQUFpQkMsQ0FBakIsRUFBb0JDLENBQXBCLEVBQXVCO0FBQ3JCLE1BQUlELENBQUMsS0FBS0MsQ0FBVixFQUFhO0FBQ1gsV0FBTyxDQUFQO0FBQ0Q7O0FBRUQsTUFBSUMsQ0FBQyxHQUFHRixDQUFDLENBQUNHLE1BQVY7QUFDQSxNQUFJQyxDQUFDLEdBQUdILENBQUMsQ0FBQ0UsTUFBVjs7QUFFQSxPQUFLLElBQUlFLENBQUMsR0FBRyxDQUFSLEVBQVdDLEdBQUcsR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVNOLENBQVQsRUFBWUUsQ0FBWixDQUF0QixFQUFzQ0MsQ0FB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LENBQVg7O0FBQ0EsTUFBSWxCLElBQUosRUFBVTtBQUNSQSxRQUFJLEdBQUdBLElBQUksQ0FBQyxDQUFELENBQVg7O0FBQ0EsUUFBSUEsSUFBSSxLQUFLLEdBQWIsRUFBa0I7QUFDaEIsV0FBS0EsSUFBTCxHQUFZQSxJQUFJLENBQUNpQixNQUFMLENBQVksQ0FBWixDQUFaO0FBQ0Q7O0FBQ0RDLFFBQUksR0FBR0EsSUFBSSxDQUFDRCxNQUFMLENBQVksQ0FBWixFQUFlQyxJQUFJLENBQUNwTSxNQUFMLEdBQWNrTCxJQUFJLENBQUNsTCxNQUFsQyxDQUFQO0FBQ0Q7O0FBQ0QsTUFBSW9NLElBQUosRUFBVSxLQUFLbkIsUUFBTCxHQUFnQm1CLElBQWhCO0FBQ1gsQ0FYRCxDOzs7Ozs7OztBQ2h0QmE7O0FBRWJwSyxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDZnlILFVBQVEsRUFBRSxrQkFBUzBmLEdBQVQsRUFBYztBQUN0QixXQUFPLE9BQU9BLEdBQVAsS0FBZ0IsUUFBdkI7QUFDRCxHQUhjO0FBSWZuVCxVQUFRLEVBQUUsa0JBQVNtVCxHQUFULEVBQWM7QUFDdEIsV0FBTyxPQUFPQSxHQUFQLEtBQWdCLFFBQWhCLElBQTRCQSxHQUFHLEtBQUssSUFBM0M7QUFDRCxHQU5jO0FBT2Y2SixRQUFNLEVBQUUsZ0JBQVM3SixHQUFULEVBQWM7QUFDcEIsV0FBT0EsR0FBRyxLQUFLLElBQWY7QUFDRCxHQVRjO0FBVWY4SixtQkFBaUIsRUFBRSwyQkFBUzlKLEdBQVQsRUFBYztBQUMvQixXQUFPQSxHQUFHLElBQUksSUFBZDtBQUNEO0FBWmMsQ0FBakIsQyIsImZpbGUiOiJ2ZW5kb3IuMDMyMTk0YzM0ZDgwMWQwMTgzNTguaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciBodHRwRm9sbG93ID0gcmVxdWlyZSgnZm9sbG93LXJlZGlyZWN0cycpLmh0dHA7XG52YXIgaHR0cHNGb2xsb3cgPSByZXF1aXJlKCdmb2xsb3ctcmVkaXJlY3RzJykuaHR0cHM7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbnZhciBwa2cgPSByZXF1aXJlKCcuLy4uLy4uL3BhY2thZ2UuanNvbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvZW5oYW5jZUVycm9yJyk7XG5cbnZhciBpc0h0dHBzID0gL2h0dHBzOj8vO1xuXG4vKmVzbGludCBjb25zaXN0ZW50LXJldHVybjowKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHR0cEFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaEh0dHBSZXF1ZXN0KHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKSB7XG4gICAgdmFyIHRpbWVyO1xuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHZhbHVlKTtcbiAgICB9O1xuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICByZWplY3RQcm9taXNlKHZhbHVlKTtcbiAgICB9O1xuICAgIHZhciBkYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIGhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIC8vIFNldCBVc2VyLUFnZW50IChyZXF1aXJlZCBieSBzb21lIHNlcnZlcnMpXG4gICAgLy8gT25seSBzZXQgaGVhZGVyIGlmIGl0IGhhc24ndCBiZWVuIHNldCBpbiBjb25maWdcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy82OVxuICAgIGlmICghaGVhZGVyc1snVXNlci1BZ2VudCddICYmICFoZWFkZXJzWyd1c2VyLWFnZW50J10pIHtcbiAgICAgIGhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9ICdheGlvcy8nICsgcGtnLnZlcnNpb247XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgIXV0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8uLi5cbiAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0Zi04Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICAgICdEYXRhIGFmdGVyIHRyYW5zZm9ybWF0aW9uIG11c3QgYmUgYSBzdHJpbmcsIGFuIEFycmF5QnVmZmVyLCBhIEJ1ZmZlciwgb3IgYSBTdHJlYW0nLFxuICAgICAgICAgIGNvbmZpZ1xuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpZiBkYXRhIGV4aXN0c1xuICAgICAgaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IGRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICB2YXIgYXV0aCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICBhdXRoID0gdXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZDtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSB1cmxcbiAgICB2YXIgcGFyc2VkID0gdXJsLnBhcnNlKGNvbmZpZy51cmwpO1xuICAgIHZhciBwcm90b2NvbCA9IHBhcnNlZC5wcm90b2NvbCB8fCAnaHR0cDonO1xuXG4gICAgaWYgKCFhdXRoICYmIHBhcnNlZC5hdXRoKSB7XG4gICAgICB2YXIgdXJsQXV0aCA9IHBhcnNlZC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIgdXJsVXNlcm5hbWUgPSB1cmxBdXRoWzBdIHx8ICcnO1xuICAgICAgdmFyIHVybFBhc3N3b3JkID0gdXJsQXV0aFsxXSB8fCAnJztcbiAgICAgIGF1dGggPSB1cmxVc2VybmFtZSArICc6JyArIHVybFBhc3N3b3JkO1xuICAgIH1cblxuICAgIGlmIChhdXRoKSB7XG4gICAgICBkZWxldGUgaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgIH1cblxuICAgIHZhciBpc0h0dHBzUmVxdWVzdCA9IGlzSHR0cHMudGVzdChwcm90b2NvbCk7XG4gICAgdmFyIGFnZW50ID0gaXNIdHRwc1JlcXVlc3QgPyBjb25maWcuaHR0cHNBZ2VudCA6IGNvbmZpZy5odHRwQWdlbnQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHBhdGg6IGJ1aWxkVVJMKHBhcnNlZC5wYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKSxcbiAgICAgIG1ldGhvZDogY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGFnZW50OiBhZ2VudCxcbiAgICAgIGF1dGg6IGF1dGhcbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5zb2NrZXRQYXRoKSB7XG4gICAgICBvcHRpb25zLnNvY2tldFBhdGggPSBjb25maWcuc29ja2V0UGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5ob3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZTtcbiAgICAgIG9wdGlvbnMucG9ydCA9IHBhcnNlZC5wb3J0O1xuICAgIH1cblxuICAgIHZhciBwcm94eSA9IGNvbmZpZy5wcm94eTtcbiAgICBpZiAoIXByb3h5ICYmIHByb3h5ICE9PSBmYWxzZSkge1xuICAgICAgdmFyIHByb3h5RW52ID0gcHJvdG9jb2wuc2xpY2UoMCwgLTEpICsgJ19wcm94eSc7XG4gICAgICB2YXIgcHJveHlVcmwgPSBwcm9jZXNzLmVudltwcm94eUVudl0gfHwgcHJvY2Vzcy5lbnZbcHJveHlFbnYudG9VcHBlckNhc2UoKV07XG4gICAgICBpZiAocHJveHlVcmwpIHtcbiAgICAgICAgdmFyIHBhcnNlZFByb3h5VXJsID0gdXJsLnBhcnNlKHByb3h5VXJsKTtcbiAgICAgICAgdmFyIG5vUHJveHlFbnYgPSBwcm9jZXNzLmVudi5ub19wcm94eSB8fCBwcm9jZXNzLmVudi5OT19QUk9YWTtcbiAgICAgICAgdmFyIHNob3VsZFByb3h5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAobm9Qcm94eUVudikge1xuICAgICAgICAgIHZhciBub1Byb3h5ID0gbm9Qcm94eUVudi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiB0cmltKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNob3VsZFByb3h5ID0gIW5vUHJveHkuc29tZShmdW5jdGlvbiBwcm94eU1hdGNoKHByb3h5RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCFwcm94eUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3h5RWxlbWVudCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3h5RWxlbWVudFswXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgcGFyc2VkLmhvc3RuYW1lLnN1YnN0cihwYXJzZWQuaG9zdG5hbWUubGVuZ3RoIC0gcHJveHlFbGVtZW50Lmxlbmd0aCkgPT09IHByb3h5RWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIHByb3h5RWxlbWVudC5tYXRjaCgvXFwuL2cpLmxlbmd0aCA9PT0gcGFyc2VkLmhvc3RuYW1lLm1hdGNoKC9cXC4vZykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkLmhvc3RuYW1lID09PSBwcm94eUVsZW1lbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChzaG91bGRQcm94eSkge1xuICAgICAgICAgIHByb3h5ID0ge1xuICAgICAgICAgICAgaG9zdDogcGFyc2VkUHJveHlVcmwuaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiBwYXJzZWRQcm94eVVybC5wb3J0XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChwYXJzZWRQcm94eVVybC5hdXRoKSB7XG4gICAgICAgICAgICB2YXIgcHJveHlVcmxBdXRoID0gcGFyc2VkUHJveHlVcmwuYXV0aC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgcHJveHkuYXV0aCA9IHtcbiAgICAgICAgICAgICAgdXNlcm5hbWU6IHByb3h5VXJsQXV0aFswXSxcbiAgICAgICAgICAgICAgcGFzc3dvcmQ6IHByb3h5VXJsQXV0aFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJveHkpIHtcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwcm94eS5ob3N0O1xuICAgICAgb3B0aW9ucy5ob3N0ID0gcHJveHkuaG9zdDtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5ob3N0ID0gcGFyc2VkLmhvc3RuYW1lICsgKHBhcnNlZC5wb3J0ID8gJzonICsgcGFyc2VkLnBvcnQgOiAnJyk7XG4gICAgICBvcHRpb25zLnBvcnQgPSBwcm94eS5wb3J0O1xuICAgICAgb3B0aW9ucy5wYXRoID0gcHJvdG9jb2wgKyAnLy8nICsgcGFyc2VkLmhvc3RuYW1lICsgKHBhcnNlZC5wb3J0ID8gJzonICsgcGFyc2VkLnBvcnQgOiAnJykgKyBvcHRpb25zLnBhdGg7XG5cbiAgICAgIC8vIEJhc2ljIHByb3h5IGF1dGhvcml6YXRpb25cbiAgICAgIGlmIChwcm94eS5hdXRoKSB7XG4gICAgICAgIHZhciBiYXNlNjQgPSBCdWZmZXIuZnJvbShwcm94eS5hdXRoLnVzZXJuYW1lICsgJzonICsgcHJveHkuYXV0aC5wYXNzd29yZCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gJ0Jhc2ljICcgKyBiYXNlNjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zcG9ydDtcbiAgICB2YXIgaXNIdHRwc1Byb3h5ID0gaXNIdHRwc1JlcXVlc3QgJiYgKHByb3h5ID8gaXNIdHRwcy50ZXN0KHByb3h5LnByb3RvY29sKSA6IHRydWUpO1xuICAgIGlmIChjb25maWcudHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnQgPSBjb25maWcudHJhbnNwb3J0O1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLm1heFJlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgdHJhbnNwb3J0ID0gaXNIdHRwc1Byb3h5ID8gaHR0cHMgOiBodHRwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZmlnLm1heFJlZGlyZWN0cykge1xuICAgICAgICBvcHRpb25zLm1heFJlZGlyZWN0cyA9IGNvbmZpZy5tYXhSZWRpcmVjdHM7XG4gICAgICB9XG4gICAgICB0cmFuc3BvcnQgPSBpc0h0dHBzUHJveHkgPyBodHRwc0ZvbGxvdyA6IGh0dHBGb2xsb3c7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoICYmIGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoID4gLTEpIHtcbiAgICAgIG9wdGlvbnMubWF4Qm9keUxlbmd0aCA9IGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgIHZhciByZXEgPSB0cmFuc3BvcnQucmVxdWVzdChvcHRpb25zLCBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXMpIHtcbiAgICAgIGlmIChyZXEuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyB1bmNvbXByZXNzIHRoZSByZXNwb25zZSBib2R5IHRyYW5zcGFyZW50bHkgaWYgcmVxdWlyZWRcbiAgICAgIHZhciBzdHJlYW0gPSByZXM7XG4gICAgICBzd2l0Y2ggKHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pIHtcbiAgICAgIC8qZXNsaW50IGRlZmF1bHQtY2FzZTowKi9cbiAgICAgIGNhc2UgJ2d6aXAnOlxuICAgICAgY2FzZSAnY29tcHJlc3MnOlxuICAgICAgY2FzZSAnZGVmbGF0ZSc6XG4gICAgICAgIC8vIGFkZCB0aGUgdW56aXBwZXIgdG8gdGhlIGJvZHkgc3RyZWFtIHByb2Nlc3NpbmcgcGlwZWxpbmVcbiAgICAgICAgc3RyZWFtID0gKHJlcy5zdGF0dXNDb2RlID09PSAyMDQpID8gc3RyZWFtIDogc3RyZWFtLnBpcGUoemxpYi5jcmVhdGVVbnppcCgpKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGNvbnRlbnQtZW5jb2RpbmcgaW4gb3JkZXIgdG8gbm90IGNvbmZ1c2UgZG93bnN0cmVhbSBvcGVyYXRpb25zXG4gICAgICAgIGRlbGV0ZSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIHRoZSBsYXN0IHJlcXVlc3QgaW4gY2FzZSBvZiByZWRpcmVjdHNcbiAgICAgIHZhciBsYXN0UmVxdWVzdCA9IHJlcy5yZXEgfHwgcmVxO1xuXG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXR1czogcmVzLnN0YXR1c0NvZGUsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNNZXNzYWdlLFxuICAgICAgICBoZWFkZXJzOiByZXMuaGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IGxhc3RSZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YSA9IHN0cmVhbTtcbiAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlQnVmZmVyID0gW107XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbURhdGEoY2h1bmspIHtcbiAgICAgICAgICByZXNwb25zZUJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgY29udGVudCBsZW5ndGggaXMgbm90IG92ZXIgdGhlIG1heENvbnRlbnRMZW5ndGggaWYgc3BlY2lmaWVkXG4gICAgICAgICAgaWYgKGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoID4gLTEgJiYgQnVmZmVyLmNvbmNhdChyZXNwb25zZUJ1ZmZlcikubGVuZ3RoID4gY29uZmlnLm1heENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ21heENvbnRlbnRMZW5ndGggc2l6ZSBvZiAnICsgY29uZmlnLm1heENvbnRlbnRMZW5ndGggKyAnIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgY29uZmlnLCBudWxsLCBsYXN0UmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVycm9yKGVycikge1xuICAgICAgICAgIGlmIChyZXEuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgIHJlamVjdChlbmhhbmNlRXJyb3IoZXJyLCBjb25maWcsIG51bGwsIGxhc3RSZXF1ZXN0KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gaGFuZGxlU3RyZWFtRW5kKCkge1xuICAgICAgICAgIHZhciByZXNwb25zZURhdGEgPSBCdWZmZXIuY29uY2F0KHJlc3BvbnNlQnVmZmVyKTtcbiAgICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2VEYXRhLnRvU3RyaW5nKGNvbmZpZy5yZXNwb25zZUVuY29kaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2VEYXRhO1xuICAgICAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgZXJyb3JzXG4gICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RFcnJvcihlcnIpIHtcbiAgICAgIGlmIChyZXEuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgcmVqZWN0KGVuaGFuY2VFcnJvcihlcnIsIGNvbmZpZywgbnVsbCwgcmVxKSk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcmVxdWVzdCB0aW1lb3V0XG4gICAgaWYgKGNvbmZpZy50aW1lb3V0KSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFRpbWVvdXQoKSB7XG4gICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxKSk7XG4gICAgICB9LCBjb25maWcudGltZW91dCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAocmVxLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgaWYgKHV0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICBkYXRhLm9uKCdlcnJvcicsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVycm9yKGVycikge1xuICAgICAgICByZWplY3QoZW5oYW5jZUVycm9yKGVyciwgY29uZmlnLCBudWxsLCByZXEpKTtcbiAgICAgIH0pLnBpcGUocmVxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLmVuZChkYXRhKTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QgPyBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCkgOiAnZ2V0JztcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gU3VwcG9ydCBiYXNlVVJMIGNvbmZpZ1xuICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcbiAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVycyB8fCB7fVxuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHV0aWxzLmZvckVhY2goWyd1cmwnLCAnbWV0aG9kJywgJ3BhcmFtcycsICdkYXRhJ10sIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICh0eXBlb2YgY29uZmlnMltwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzJbcHJvcF07XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5J10sIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICh1dGlscy5pc09iamVjdChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gdXRpbHMuZGVlcE1lcmdlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZzJbcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBjb25maWcyW3Byb3BdO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IHV0aWxzLmRlZXBNZXJnZShjb25maWcxW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWcxW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnW3Byb3BdID0gY29uZmlnMVtwcm9wXTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnbWF4Q29udGVudExlbmd0aCcsXG4gICAgJ3ZhbGlkYXRlU3RhdHVzJywgJ21heFJlZGlyZWN0cycsICdodHRwQWdlbnQnLCAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsXG4gICAgJ3NvY2tldFBhdGgnXG4gIF0sIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICh0eXBlb2YgY29uZmlnMltwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzJbcHJvcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnMVtwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzFbcHJvcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIC8vIE9ubHkgTm9kZS5KUyBoYXMgYSBwcm9jZXNzIHZhcmlhYmxlIHRoYXQgaXMgb2YgW1tDbGFzc11dIHByb2Nlc3NcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZXF1YWwgdG8gbWVyZ2Ugd2l0aCB0aGUgZGlmZmVyZW5jZSBiZWluZyB0aGF0IG5vIHJlZmVyZW5jZVxuICogdG8gb3JpZ2luYWwgb2JqZWN0cyBpcyBrZXB0LlxuICpcbiAqIEBzZWUgbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGRlZXBNZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBkZWVwTWVyZ2U6IGRlZXBNZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBac3RyZWFtID0gcmVxdWlyZSgncGFrby9saWIvemxpYi96c3RyZWFtJyk7XG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9kZWZsYXRlLmpzJyk7XG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9pbmZsYXRlLmpzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9jb25zdGFudHMnKTtcblxuZm9yICh2YXIga2V5IGluIGNvbnN0YW50cykge1xuICBleHBvcnRzW2tleV0gPSBjb25zdGFudHNba2V5XTtcbn1cblxuLy8gemxpYiBtb2Rlc1xuZXhwb3J0cy5OT05FID0gMDtcbmV4cG9ydHMuREVGTEFURSA9IDE7XG5leHBvcnRzLklORkxBVEUgPSAyO1xuZXhwb3J0cy5HWklQID0gMztcbmV4cG9ydHMuR1VOWklQID0gNDtcbmV4cG9ydHMuREVGTEFURVJBVyA9IDU7XG5leHBvcnRzLklORkxBVEVSQVcgPSA2O1xuZXhwb3J0cy5VTlpJUCA9IDc7XG5cbnZhciBHWklQX0hFQURFUl9JRDEgPSAweDFmO1xudmFyIEdaSVBfSEVBREVSX0lEMiA9IDB4OGI7XG5cbi8qKlxuICogRW11bGF0ZSBOb2RlJ3MgemxpYiBDKysgbGF5ZXIgZm9yIHVzZSBieSB0aGUgSlMgbGF5ZXIgaW4gaW5kZXguanNcbiAqL1xuZnVuY3Rpb24gWmxpYihtb2RlKSB7XG4gIGlmICh0eXBlb2YgbW9kZSAhPT0gJ251bWJlcicgfHwgbW9kZSA8IGV4cG9ydHMuREVGTEFURSB8fCBtb2RlID4gZXhwb3J0cy5VTlpJUCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5kaWN0aW9uYXJ5ID0gbnVsbDtcbiAgdGhpcy5lcnIgPSAwO1xuICB0aGlzLmZsdXNoID0gMDtcbiAgdGhpcy5pbml0X2RvbmUgPSBmYWxzZTtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMubWVtTGV2ZWwgPSAwO1xuICB0aGlzLm1vZGUgPSBtb2RlO1xuICB0aGlzLnN0cmF0ZWd5ID0gMDtcbiAgdGhpcy53aW5kb3dCaXRzID0gMDtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICB0aGlzLnBlbmRpbmdfY2xvc2UgPSBmYWxzZTtcbiAgdGhpcy5nemlwX2lkX2J5dGVzX3JlYWQgPSAwO1xufVxuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MpIHtcbiAgICB0aGlzLnBlbmRpbmdfY2xvc2UgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuXG4gIGFzc2VydCh0aGlzLmluaXRfZG9uZSwgJ2Nsb3NlIGJlZm9yZSBpbml0Jyk7XG4gIGFzc2VydCh0aGlzLm1vZGUgPD0gZXhwb3J0cy5VTlpJUCk7XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURSB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1VOWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5JTkZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5VTlpJUCkge1xuICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH1cblxuICB0aGlzLm1vZGUgPSBleHBvcnRzLk5PTkU7XG5cbiAgdGhpcy5kaWN0aW9uYXJ5ID0gbnVsbDtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikge1xuICByZXR1cm4gdGhpcy5fd3JpdGUodHJ1ZSwgZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlU3luYyA9IGZ1bmN0aW9uIChmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgcmV0dXJuIHRoaXMuX3dyaXRlKGZhbHNlLCBmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGFzeW5jLCBmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgYXNzZXJ0LmVxdWFsKGFyZ3VtZW50cy5sZW5ndGgsIDgpO1xuXG4gIGFzc2VydCh0aGlzLmluaXRfZG9uZSwgJ3dyaXRlIGJlZm9yZSBpbml0Jyk7XG4gIGFzc2VydCh0aGlzLm1vZGUgIT09IGV4cG9ydHMuTk9ORSwgJ2FscmVhZHkgZmluYWxpemVkJyk7XG4gIGFzc2VydC5lcXVhbChmYWxzZSwgdGhpcy53cml0ZV9pbl9wcm9ncmVzcywgJ3dyaXRlIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgYXNzZXJ0LmVxdWFsKGZhbHNlLCB0aGlzLnBlbmRpbmdfY2xvc2UsICdjbG9zZSBpcyBwZW5kaW5nJyk7XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG5cbiAgYXNzZXJ0LmVxdWFsKGZhbHNlLCBmbHVzaCA9PT0gdW5kZWZpbmVkLCAnbXVzdCBwcm92aWRlIGZsdXNoIHZhbHVlJyk7XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG5cbiAgaWYgKGZsdXNoICE9PSBleHBvcnRzLlpfTk9fRkxVU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9QQVJUSUFMX0ZMVVNIICYmIGZsdXNoICE9PSBleHBvcnRzLlpfU1lOQ19GTFVTSCAmJiBmbHVzaCAhPT0gZXhwb3J0cy5aX0ZVTExfRkxVU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9GSU5JU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9CTE9DSykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCB2YWx1ZScpO1xuICB9XG5cbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICBpbnB1dCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpbl9sZW4gPSAwO1xuICAgIGluX29mZiA9IDA7XG4gIH1cblxuICB0aGlzLnN0cm0uYXZhaWxfaW4gPSBpbl9sZW47XG4gIHRoaXMuc3RybS5pbnB1dCA9IGlucHV0O1xuICB0aGlzLnN0cm0ubmV4dF9pbiA9IGluX29mZjtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IG91dF9sZW47XG4gIHRoaXMuc3RybS5vdXRwdXQgPSBvdXQ7XG4gIHRoaXMuc3RybS5uZXh0X291dCA9IG91dF9vZmY7XG4gIHRoaXMuZmx1c2ggPSBmbHVzaDtcblxuICBpZiAoIWFzeW5jKSB7XG4gICAgLy8gc3luYyB2ZXJzaW9uXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrRXJyb3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FmdGVyU3luYygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhc3luYyB2ZXJzaW9uXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fcHJvY2VzcygpO1xuICAgIHNlbGYuX2FmdGVyKCk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2FmdGVyU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF2YWlsX291dCA9IHRoaXMuc3RybS5hdmFpbF9vdXQ7XG4gIHZhciBhdmFpbF9pbiA9IHRoaXMuc3RybS5hdmFpbF9pbjtcblxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG5cbiAgcmV0dXJuIFthdmFpbF9pbiwgYXZhaWxfb3V0XTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9IG51bGw7XG5cbiAgLy8gSWYgdGhlIGF2YWlsX291dCBpcyBsZWZ0IGF0IDAsIHRoZW4gaXQgbWVhbnMgdGhhdCBpdCByYW4gb3V0XG4gIC8vIG9mIHJvb20uICBJZiB0aGVyZSB3YXMgYXZhaWxfb3V0IGxlZnQgb3ZlciwgdGhlbiBpdCBtZWFuc1xuICAvLyB0aGF0IGFsbCBvZiB0aGUgaW5wdXQgd2FzIGNvbnN1bWVkLlxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZSh0aGlzLnN0cm0sIHRoaXMuZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgICAgaWYgKHRoaXMuc3RybS5hdmFpbF9pbiA+IDApIHtcbiAgICAgICAgbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9IHRoaXMuc3RybS5uZXh0X2luO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuZ3ppcF9pZF9ieXRlc19yZWFkKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAobmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3RybS5pbnB1dFtuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlXSA9PT0gR1pJUF9IRUFERVJfSUQxKSB7XG4gICAgICAgICAgICB0aGlzLmd6aXBfaWRfYnl0ZXNfcmVhZCA9IDE7XG4gICAgICAgICAgICBuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlKys7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cm0uYXZhaWxfaW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgYXZhaWxhYmxlIGJ5dGUgd2FzIGFscmVhZHkgcmVhZC5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGV4cG9ydHMuSU5GTEFURTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKG5leHRfZXhwZWN0ZWRfaGVhZGVyX2J5dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0cm0uaW5wdXRbbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZV0gPT09IEdaSVBfSEVBREVSX0lEMikge1xuICAgICAgICAgICAgdGhpcy5nemlwX2lkX2J5dGVzX3JlYWQgPSAyO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gZXhwb3J0cy5HVU5aSVA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGFjdHVhbCBkaWZmZXJlbmNlIGJldHdlZW4gSU5GTEFURSBhbmQgSU5GTEFURVJBV1xuICAgICAgICAgICAgLy8gKGFmdGVyIGluaXRpYWxpemF0aW9uKS5cbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGV4cG9ydHMuSU5GTEFURTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbnVtYmVyIG9mIGd6aXAgbWFnaWMgbnVtYmVyIGJ5dGVzIHJlYWQnKTtcbiAgICAgIH1cblxuICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGUodGhpcy5zdHJtLCB0aGlzLmZsdXNoXG5cbiAgICAgIC8vIElmIGRhdGEgd2FzIGVuY29kZWQgd2l0aCBkaWN0aW9uYXJ5XG4gICAgICApO2lmICh0aGlzLmVyciA9PT0gZXhwb3J0cy5aX05FRURfRElDVCAmJiB0aGlzLmRpY3Rpb25hcnkpIHtcbiAgICAgICAgLy8gTG9hZCBpdFxuICAgICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIHRoaXMuZGljdGlvbmFyeSk7XG4gICAgICAgIGlmICh0aGlzLmVyciA9PT0gZXhwb3J0cy5aX09LKSB7XG4gICAgICAgICAgLy8gQW5kIHRyeSB0byBkZWNvZGUgYWdhaW5cbiAgICAgICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHRoaXMuc3RybSwgdGhpcy5mbHVzaCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lcnIgPT09IGV4cG9ydHMuWl9EQVRBX0VSUk9SKSB7XG4gICAgICAgICAgLy8gQm90aCBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGFuZCBpbmZsYXRlKCkgcmV0dXJuIFpfREFUQV9FUlJPUi5cbiAgICAgICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIGZvciBBZnRlcigpIHRvIHRlbGwgYSBiYWQgZGljdGlvbmFyeSBmcm9tIGJhZFxuICAgICAgICAgIC8vIGlucHV0LlxuICAgICAgICAgIHRoaXMuZXJyID0gZXhwb3J0cy5aX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHRoaXMuc3RybS5hdmFpbF9pbiA+IDAgJiYgdGhpcy5tb2RlID09PSBleHBvcnRzLkdVTlpJUCAmJiB0aGlzLmVyciA9PT0gZXhwb3J0cy5aX1NUUkVBTV9FTkQgJiYgdGhpcy5zdHJtLm5leHRfaW5bMF0gIT09IDB4MDApIHtcbiAgICAgICAgLy8gQnl0ZXMgcmVtYWluIGluIGlucHV0IGJ1ZmZlci4gUGVyaGFwcyB0aGlzIGlzIGFub3RoZXIgY29tcHJlc3NlZFxuICAgICAgICAvLyBtZW1iZXIgaW4gdGhlIHNhbWUgYXJjaGl2ZSwgb3IganVzdCB0cmFpbGluZyBnYXJiYWdlLlxuICAgICAgICAvLyBUcmFpbGluZyB6ZXJvIGJ5dGVzIGFyZSBva2F5LCB0aG91Z2gsIHNpbmNlIHRoZXkgYXJlIGZyZXF1ZW50bHlcbiAgICAgICAgLy8gdXNlZCBmb3IgcGFkZGluZy5cblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGUodGhpcy5zdHJtLCB0aGlzLmZsdXNoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSAnICsgdGhpcy5tb2RlKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX2NoZWNrRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEFjY2VwdGFibGUgZXJyb3Igc3RhdGVzIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiB6bGliIHN0cmVhbS5cbiAgc3dpdGNoICh0aGlzLmVycikge1xuICAgIGNhc2UgZXhwb3J0cy5aX09LOlxuICAgIGNhc2UgZXhwb3J0cy5aX0JVRl9FUlJPUjpcbiAgICAgIGlmICh0aGlzLnN0cm0uYXZhaWxfb3V0ICE9PSAwICYmIHRoaXMuZmx1c2ggPT09IGV4cG9ydHMuWl9GSU5JU0gpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlpfU1RSRUFNX0VORDpcbiAgICAgIC8vIG5vcm1hbCBzdGF0dXNlcywgbm90IGZhdGFsXG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuWl9ORUVEX0RJQ1Q6XG4gICAgICBpZiAodGhpcy5kaWN0aW9uYXJ5ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ01pc3NpbmcgZGljdGlvbmFyeScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ0JhZCBkaWN0aW9uYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHNvbWV0aGluZyBlbHNlLlxuICAgICAgdGhpcy5fZXJyb3IoJ1psaWIgZXJyb3InKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2FmdGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX2NoZWNrRXJyb3IoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhdmFpbF9vdXQgPSB0aGlzLnN0cm0uYXZhaWxfb3V0O1xuICB2YXIgYXZhaWxfaW4gPSB0aGlzLnN0cm0uYXZhaWxfaW47XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuXG4gIC8vIGNhbGwgdGhlIHdyaXRlKCkgY2JcbiAgdGhpcy5jYWxsYmFjayhhdmFpbF9pbiwgYXZhaWxfb3V0KTtcblxuICBpZiAodGhpcy5wZW5kaW5nX2Nsb3NlKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBpZiAodGhpcy5zdHJtLm1zZykge1xuICAgIG1lc3NhZ2UgPSB0aGlzLnN0cm0ubXNnO1xuICB9XG4gIHRoaXMub25lcnJvcihtZXNzYWdlLCB0aGlzLmVyclxuXG4gIC8vIG5vIGhvcGUgb2YgcmVzY3VlLlxuICApO3RoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGVuZGluZ19jbG9zZSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh3aW5kb3dCaXRzLCBsZXZlbCwgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBkaWN0aW9uYXJ5KSB7XG4gIGFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSA0IHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDUsICdpbml0KHdpbmRvd0JpdHMsIGxldmVsLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIFtkaWN0aW9uYXJ5XSknKTtcblxuICBhc3NlcnQod2luZG93Qml0cyA+PSA4ICYmIHdpbmRvd0JpdHMgPD0gMTUsICdpbnZhbGlkIHdpbmRvd0JpdHMnKTtcbiAgYXNzZXJ0KGxldmVsID49IC0xICYmIGxldmVsIDw9IDksICdpbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsJyk7XG5cbiAgYXNzZXJ0KG1lbUxldmVsID49IDEgJiYgbWVtTGV2ZWwgPD0gOSwgJ2ludmFsaWQgbWVtbGV2ZWwnKTtcblxuICBhc3NlcnQoc3RyYXRlZ3kgPT09IGV4cG9ydHMuWl9GSUxURVJFRCB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX1JMRSB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX0ZJWEVEIHx8IHN0cmF0ZWd5ID09PSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSwgJ2ludmFsaWQgc3RyYXRlZ3knKTtcblxuICB0aGlzLl9pbml0KGxldmVsLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIGRpY3Rpb25hcnkpO1xuICB0aGlzLl9zZXREaWN0aW9uYXJ5KCk7XG59O1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignZGVmbGF0ZVBhcmFtcyBOb3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5abGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5fc2V0RGljdGlvbmFyeSgpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAobGV2ZWwsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSwgZGljdGlvbmFyeSkge1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIHRoaXMud2luZG93Qml0cyA9IHdpbmRvd0JpdHM7XG4gIHRoaXMubWVtTGV2ZWwgPSBtZW1MZXZlbDtcbiAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuXG4gIHRoaXMuZmx1c2ggPSBleHBvcnRzLlpfTk9fRkxVU0g7XG5cbiAgdGhpcy5lcnIgPSBleHBvcnRzLlpfT0s7XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HVU5aSVApIHtcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLlVOWklQKSB7XG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5JTkZMQVRFUkFXKSB7XG4gICAgdGhpcy53aW5kb3dCaXRzID0gLTEgKiB0aGlzLndpbmRvd0JpdHM7XG4gIH1cblxuICB0aGlzLnN0cm0gPSBuZXcgWnN0cmVhbSgpO1xuXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCB0aGlzLmxldmVsLCBleHBvcnRzLlpfREVGTEFURUQsIHRoaXMud2luZG93Qml0cywgdGhpcy5tZW1MZXZlbCwgdGhpcy5zdHJhdGVneSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgIGNhc2UgZXhwb3J0cy5VTlpJUDpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sIHRoaXMud2luZG93Qml0cyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgJyArIHRoaXMubW9kZSk7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdJbml0IGVycm9yJyk7XG4gIH1cblxuICB0aGlzLmRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5O1xuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3NldERpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmRpY3Rpb25hcnkgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyID0gZXhwb3J0cy5aX09LO1xuXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIHRoaXMuZGljdGlvbmFyeSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdGYWlsZWQgdG8gc2V0IGRpY3Rpb25hcnknKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVyciA9IGV4cG9ydHMuWl9PSztcblxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdGYWlsZWQgdG8gcmVzZXQgc3RyZWFtJyk7XG4gIH1cbn07XG5cbmV4cG9ydHMuWmxpYiA9IFpsaWI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbnZhciBiaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKS5vaztcbnZhciBrTWF4TGVuZ3RoID0gcmVxdWlyZSgnYnVmZmVyJykua01heExlbmd0aDtcbnZhciBrUmFuZ2VFcnJvck1lc3NhZ2UgPSAnQ2Fubm90IGNyZWF0ZSBmaW5hbCBCdWZmZXIuIEl0IHdvdWxkIGJlIGxhcmdlciAnICsgJ3RoYW4gMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJztcblxuLy8gemxpYiBkb2Vzbid0IHByb3ZpZGUgdGhlc2UsIHNvIGtsdWRnZSB0aGVtIGluIGZvbGxvd2luZyB0aGUgc2FtZVxuLy8gY29uc3QgbmFtaW5nIHNjaGVtZSB6bGliIHVzZXMuXG5iaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgPSA4O1xuYmluZGluZy5aX01BWF9XSU5ET1dCSVRTID0gMTU7XG5iaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTID0gMTU7XG5cbi8vIGZld2VyIHRoYW4gNjQgYnl0ZXMgcGVyIGNodW5rIGlzIHN0dXBpZC5cbi8vIHRlY2huaWNhbGx5IGl0IGNvdWxkIHdvcmsgd2l0aCBhcyBmZXcgYXMgOCwgYnV0IGV2ZW4gNjQgYnl0ZXNcbi8vIGlzIGFic3VyZGx5IGxvdy4gIFVzdWFsbHkgYSBNQiBvciBtb3JlIGlzIGJlc3QuXG5iaW5kaW5nLlpfTUlOX0NIVU5LID0gNjQ7XG5iaW5kaW5nLlpfTUFYX0NIVU5LID0gSW5maW5pdHk7XG5iaW5kaW5nLlpfREVGQVVMVF9DSFVOSyA9IDE2ICogMTAyNDtcblxuYmluZGluZy5aX01JTl9NRU1MRVZFTCA9IDE7XG5iaW5kaW5nLlpfTUFYX01FTUxFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX01FTUxFVkVMID0gODtcblxuYmluZGluZy5aX01JTl9MRVZFTCA9IC0xO1xuYmluZGluZy5aX01BWF9MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9MRVZFTCA9IGJpbmRpbmcuWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuXG4vLyBleHBvc2UgYWxsIHRoZSB6bGliIGNvbnN0YW50c1xudmFyIGJrZXlzID0gT2JqZWN0LmtleXMoYmluZGluZyk7XG5mb3IgKHZhciBiayA9IDA7IGJrIDwgYmtleXMubGVuZ3RoOyBiaysrKSB7XG4gIHZhciBia2V5ID0gYmtleXNbYmtdO1xuICBpZiAoYmtleS5tYXRjaCgvXlovKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBia2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogYmluZGluZ1tia2V5XSwgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gdHJhbnNsYXRpb24gdGFibGUgZm9yIHJldHVybiBjb2Rlcy5cbnZhciBjb2RlcyA9IHtcbiAgWl9PSzogYmluZGluZy5aX09LLFxuICBaX1NUUkVBTV9FTkQ6IGJpbmRpbmcuWl9TVFJFQU1fRU5ELFxuICBaX05FRURfRElDVDogYmluZGluZy5aX05FRURfRElDVCxcbiAgWl9FUlJOTzogYmluZGluZy5aX0VSUk5PLFxuICBaX1NUUkVBTV9FUlJPUjogYmluZGluZy5aX1NUUkVBTV9FUlJPUixcbiAgWl9EQVRBX0VSUk9SOiBiaW5kaW5nLlpfREFUQV9FUlJPUixcbiAgWl9NRU1fRVJST1I6IGJpbmRpbmcuWl9NRU1fRVJST1IsXG4gIFpfQlVGX0VSUk9SOiBiaW5kaW5nLlpfQlVGX0VSUk9SLFxuICBaX1ZFUlNJT05fRVJST1I6IGJpbmRpbmcuWl9WRVJTSU9OX0VSUk9SXG59O1xuXG52YXIgY2tleXMgPSBPYmplY3Qua2V5cyhjb2Rlcyk7XG5mb3IgKHZhciBjayA9IDA7IGNrIDwgY2tleXMubGVuZ3RoOyBjaysrKSB7XG4gIHZhciBja2V5ID0gY2tleXNbY2tdO1xuICBjb2Rlc1tjb2Rlc1tja2V5XV0gPSBja2V5O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NvZGVzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogT2JqZWN0LmZyZWV6ZShjb2RlcyksIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5HemlwID0gR3ppcDtcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwO1xuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhdztcbmV4cG9ydHMuSW5mbGF0ZVJhdyA9IEluZmxhdGVSYXc7XG5leHBvcnRzLlVuemlwID0gVW56aXA7XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZVJhdyA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZVJhdyA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3ppcCA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgR3ppcChvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3VuemlwID0gZnVuY3Rpb24gKG8pIHtcbiAgcmV0dXJuIG5ldyBHdW56aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVVuemlwID0gZnVuY3Rpb24gKG8pIHtcbiAgcmV0dXJuIG5ldyBVbnppcChvKTtcbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZHMuXG4vLyBjb21wcmVzcy9kZWNvbXByZXNzIGEgc3RyaW5nIG9yIGJ1ZmZlciBpbiBvbmUgc3RlcC5cbmV4cG9ydHMuZGVmbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5nemlwID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgR3ppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmd6aXBTeW5jID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd6aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVSYXcgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgRGVmbGF0ZVJhdyhvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMudW56aXAgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLnVuemlwU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5ndW56aXAgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5ndW56aXBTeW5jID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd1bnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3U3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlcihlbmdpbmUsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIG5yZWFkID0gMDtcblxuICBlbmdpbmUub24oJ2Vycm9yJywgb25FcnJvcik7XG4gIGVuZ2luZS5vbignZW5kJywgb25FbmQpO1xuXG4gIGVuZ2luZS5lbmQoYnVmZmVyKTtcbiAgZmxvdygpO1xuXG4gIGZ1bmN0aW9uIGZsb3coKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlIChudWxsICE9PSAoY2h1bmsgPSBlbmdpbmUucmVhZCgpKSkge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgZW5naW5lLm9uY2UoJ3JlYWRhYmxlJywgZmxvdyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBmbG93KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdmFyIGJ1ZjtcbiAgICB2YXIgZXJyID0gbnVsbDtcblxuICAgIGlmIChucmVhZCA+PSBrTWF4TGVuZ3RoKSB7XG4gICAgICBlcnIgPSBuZXcgUmFuZ2VFcnJvcihrUmFuZ2VFcnJvck1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICB9XG5cbiAgICBidWZmZXJzID0gW107XG4gICAgZW5naW5lLmNsb3NlKCk7XG4gICAgY2FsbGJhY2soZXJyLCBidWYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXJTeW5jKGVuZ2luZSwgYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG5cbiAgdmFyIGZsdXNoRmxhZyA9IGVuZ2luZS5fZmluaXNoRmx1c2hGbGFnO1xuXG4gIHJldHVybiBlbmdpbmUuX3Byb2Nlc3NDaHVuayhidWZmZXIsIGZsdXNoRmxhZyk7XG59XG5cbi8vIGdlbmVyaWMgemxpYlxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEUpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEUpO1xufVxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5mdW5jdGlvbiBHemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd6aXApKSByZXR1cm4gbmV3IEd6aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdaSVApO1xufVxuXG5mdW5jdGlvbiBHdW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3VuemlwKSkgcmV0dXJuIG5ldyBHdW56aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdVTlpJUCk7XG59XG5cbi8vIHJhdyAtIG5vIGhlYWRlclxuZnVuY3Rpb24gRGVmbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlUmF3KSkgcmV0dXJuIG5ldyBEZWZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5ERUZMQVRFUkFXKTtcbn1cblxuZnVuY3Rpb24gSW5mbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlUmF3KSkgcmV0dXJuIG5ldyBJbmZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5JTkZMQVRFUkFXKTtcbn1cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuZnVuY3Rpb24gVW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW56aXApKSByZXR1cm4gbmV3IFVuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5VTlpJUCk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRGbHVzaEZsYWcoZmxhZykge1xuICByZXR1cm4gZmxhZyA9PT0gYmluZGluZy5aX05PX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9QQVJUSUFMX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9TWU5DX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9GVUxMX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9GSU5JU0ggfHwgZmxhZyA9PT0gYmluZGluZy5aX0JMT0NLO1xufVxuXG4vLyB0aGUgWmxpYiBjbGFzcyB0aGV5IGFsbCBpbmhlcml0IGZyb21cbi8vIFRoaXMgdGhpbmcgbWFuYWdlcyB0aGUgcXVldWUgb2YgcmVxdWVzdHMsIGFuZCByZXR1cm5zXG4vLyB0cnVlIG9yIGZhbHNlIGlmIHRoZXJlIGlzIGFueXRoaW5nIGluIHRoZSBxdWV1ZSB3aGVuXG4vLyB5b3UgY2FsbCB0aGUgLndyaXRlKCkgbWV0aG9kLlxuXG5mdW5jdGlvbiBabGliKG9wdHMsIG1vZGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLl9vcHRzID0gb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX2NodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IGV4cG9ydHMuWl9ERUZBVUxUX0NIVU5LO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChvcHRzLmZsdXNoICYmICFpc1ZhbGlkRmx1c2hGbGFnKG9wdHMuZmx1c2gpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIGZsYWc6ICcgKyBvcHRzLmZsdXNoKTtcbiAgfVxuICBpZiAob3B0cy5maW5pc2hGbHVzaCAmJiAhaXNWYWxpZEZsdXNoRmxhZyhvcHRzLmZpbmlzaEZsdXNoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCBmbGFnOiAnICsgb3B0cy5maW5pc2hGbHVzaCk7XG4gIH1cblxuICB0aGlzLl9mbHVzaEZsYWcgPSBvcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgdGhpcy5fZmluaXNoRmx1c2hGbGFnID0gdHlwZW9mIG9wdHMuZmluaXNoRmx1c2ggIT09ICd1bmRlZmluZWQnID8gb3B0cy5maW5pc2hGbHVzaCA6IGJpbmRpbmcuWl9GSU5JU0g7XG5cbiAgaWYgKG9wdHMuY2h1bmtTaXplKSB7XG4gICAgaWYgKG9wdHMuY2h1bmtTaXplIDwgZXhwb3J0cy5aX01JTl9DSFVOSyB8fCBvcHRzLmNodW5rU2l6ZSA+IGV4cG9ydHMuWl9NQVhfQ0hVTkspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaHVuayBzaXplOiAnICsgb3B0cy5jaHVua1NpemUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLndpbmRvd0JpdHMpIHtcbiAgICBpZiAob3B0cy53aW5kb3dCaXRzIDwgZXhwb3J0cy5aX01JTl9XSU5ET1dCSVRTIHx8IG9wdHMud2luZG93Qml0cyA+IGV4cG9ydHMuWl9NQVhfV0lORE9XQklUUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvd0JpdHM6ICcgKyBvcHRzLndpbmRvd0JpdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmxldmVsKSB7XG4gICAgaWYgKG9wdHMubGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8IG9wdHMubGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBvcHRzLmxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tZW1MZXZlbCkge1xuICAgIGlmIChvcHRzLm1lbUxldmVsIDwgZXhwb3J0cy5aX01JTl9NRU1MRVZFTCB8fCBvcHRzLm1lbUxldmVsID4gZXhwb3J0cy5aX01BWF9NRU1MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbUxldmVsOiAnICsgb3B0cy5tZW1MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kpIHtcbiAgICBpZiAob3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiYgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJiBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJiBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBvcHRzLnN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kaWN0aW9uYXJ5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0cy5kaWN0aW9uYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpY3Rpb25hcnk6IGl0IHNob3VsZCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2hhbmRsZSA9IG5ldyBiaW5kaW5nLlpsaWIobW9kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9oYW5kbGUub25lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJubykge1xuICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgIF9jbG9zZShzZWxmKTtcbiAgICBzZWxmLl9oYWRFcnJvciA9IHRydWU7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgICBlcnJvci5jb2RlID0gZXhwb3J0cy5jb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBleHBvcnRzLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5faGFuZGxlLmluaXQob3B0cy53aW5kb3dCaXRzIHx8IGV4cG9ydHMuWl9ERUZBVUxUX1dJTkRPV0JJVFMsIGxldmVsLCBvcHRzLm1lbUxldmVsIHx8IGV4cG9ydHMuWl9ERUZBVUxUX01FTUxFVkVMLCBzdHJhdGVneSwgb3B0cy5kaWN0aW9uYXJ5KTtcblxuICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIHRoaXMuY2xvc2UpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2Nsb3NlZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhX3RoaXMuX2hhbmRsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKFpsaWIsIFRyYW5zZm9ybSk7XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uIChsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHwgbGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBsZXZlbCk7XG4gIH1cbiAgaWYgKHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSUxURVJFRCAmJiBzdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiYgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJWEVEICYmIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHJhdGVneTogJyArIHN0cmF0ZWd5KTtcbiAgfVxuXG4gIGlmICh0aGlzLl9sZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy5fc3RyYXRlZ3kgIT09IHN0cmF0ZWd5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZmx1c2goYmluZGluZy5aX1NZTkNfRkxVU0gsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFzc2VydChzZWxmLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgICBzZWxmLl9oYW5kbGUucGFyYW1zKGxldmVsLCBzdHJhdGVneSk7XG4gICAgICBpZiAoIXNlbGYuX2hhZEVycm9yKSB7XG4gICAgICAgIHNlbGYuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIHNlbGYuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydCh0aGlzLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gIHJldHVybiB0aGlzLl9oYW5kbGUucmVzZXQoKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIF9mbHVzaCBmdW5jdGlvbiBjYWxsZWQgYnkgdGhlIHRyYW5zZm9ybSBjbGFzcyxcbi8vIGludGVybmFsbHksIHdoZW4gdGhlIGxhc3QgY2h1bmsgaGFzIGJlZW4gd3JpdHRlbi5cblpsaWIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0oQnVmZmVyLmFsbG9jKDApLCAnJywgY2FsbGJhY2spO1xufTtcblxuWmxpYi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwga2luZCA9PT0gdW5kZWZpbmVkICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0ga2luZDtcbiAgICBraW5kID0gYmluZGluZy5aX0ZVTExfRkxVU0g7XG4gIH1cblxuICBpZiAod3MuZW5kZWQpIHtcbiAgICBpZiAoY2FsbGJhY2spIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5vbmNlKCdlbmQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAod3MubmVlZERyYWluKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmZsdXNoKGtpbmQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUoQnVmZmVyLmFsbG9jKDApLCAnJywgY2FsbGJhY2spO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBfY2xvc2UodGhpcywgY2FsbGJhY2spO1xuICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIF9jbG9zZShlbmdpbmUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgLy8gQ2FsbGVyIG1heSBpbnZva2UgLmNsb3NlIGFmdGVyIGEgemxpYiBlcnJvciAod2hpY2ggd2lsbCBudWxsIF9oYW5kbGUpLlxuICBpZiAoIWVuZ2luZS5faGFuZGxlKSByZXR1cm47XG5cbiAgZW5naW5lLl9oYW5kbGUuY2xvc2UoKTtcbiAgZW5naW5lLl9oYW5kbGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuWmxpYi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBmbHVzaEZsYWc7XG4gIHZhciB3cyA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBlbmRpbmcgPSB3cy5lbmRpbmcgfHwgd3MuZW5kZWQ7XG4gIHZhciBsYXN0ID0gZW5kaW5nICYmICghY2h1bmsgfHwgd3MubGVuZ3RoID09PSBjaHVuay5sZW5ndGgpO1xuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgcmV0dXJuIGNiKG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCcpKTtcblxuICBpZiAoIXRoaXMuX2hhbmRsZSkgcmV0dXJuIGNiKG5ldyBFcnJvcignemxpYiBiaW5kaW5nIGNsb3NlZCcpKTtcblxuICAvLyBJZiBpdCdzIHRoZSBsYXN0IGNodW5rLCBvciBhIGZpbmFsIGZsdXNoLCB3ZSB1c2UgdGhlIFpfRklOSVNIIGZsdXNoIGZsYWdcbiAgLy8gKG9yIHdoYXRldmVyIGZsYWcgd2FzIHByb3ZpZGVkIHVzaW5nIG9wdHMuZmluaXNoRmx1c2gpLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KSBmbHVzaEZsYWcgPSB0aGlzLl9maW5pc2hGbHVzaEZsYWc7ZWxzZSB7XG4gICAgZmx1c2hGbGFnID0gdGhpcy5fZmx1c2hGbGFnO1xuICAgIC8vIG9uY2Ugd2UndmUgZmx1c2hlZCB0aGUgbGFzdCBvZiB0aGUgcXVldWUsIHN0b3AgZmx1c2hpbmcgYW5kXG4gICAgLy8gZ28gYmFjayB0byB0aGUgbm9ybWFsIGJlaGF2aW9yLlxuICAgIGlmIChjaHVuay5sZW5ndGggPj0gd3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9mbHVzaEZsYWcgPSB0aGlzLl9vcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZywgY2IpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3Byb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaywgZmx1c2hGbGFnLCBjYikge1xuICB2YXIgYXZhaWxJbkJlZm9yZSA9IGNodW5rICYmIGNodW5rLmxlbmd0aDtcbiAgdmFyIGF2YWlsT3V0QmVmb3JlID0gdGhpcy5fY2h1bmtTaXplIC0gdGhpcy5fb2Zmc2V0O1xuICB2YXIgaW5PZmYgPSAwO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgYXN5bmMgPSB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKCFhc3luYykge1xuICAgIHZhciBidWZmZXJzID0gW107XG4gICAgdmFyIG5yZWFkID0gMDtcblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcikge1xuICAgICAgZXJyb3IgPSBlcjtcbiAgICB9KTtcblxuICAgIGFzc2VydCh0aGlzLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgZG8ge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuX2hhbmRsZS53cml0ZVN5bmMoZmx1c2hGbGFnLCBjaHVuaywgLy8gaW5cbiAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cbiAgICB9IHdoaWxlICghdGhpcy5faGFkRXJyb3IgJiYgY2FsbGJhY2socmVzWzBdLCByZXNbMV0pKTtcblxuICAgIGlmICh0aGlzLl9oYWRFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG5yZWFkID49IGtNYXhMZW5ndGgpIHtcbiAgICAgIF9jbG9zZSh0aGlzKTtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGtSYW5nZUVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIF9jbG9zZSh0aGlzKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBhc3NlcnQodGhpcy5faGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICB2YXIgcmVxID0gdGhpcy5faGFuZGxlLndyaXRlKGZsdXNoRmxhZywgY2h1bmssIC8vIGluXG4gIGluT2ZmLCAvLyBpbl9vZmZcbiAgYXZhaWxJbkJlZm9yZSwgLy8gaW5fbGVuXG4gIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuXG4gIHJlcS5idWZmZXIgPSBjaHVuaztcbiAgcmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2soYXZhaWxJbkFmdGVyLCBhdmFpbE91dEFmdGVyKSB7XG4gICAgLy8gV2hlbiB0aGUgY2FsbGJhY2sgaXMgdXNlZCBpbiBhbiBhc3luYyB3cml0ZSwgdGhlIGNhbGxiYWNrJ3NcbiAgICAvLyBjb250ZXh0IGlzIHRoZSBgcmVxYCBvYmplY3QgdGhhdCB3YXMgY3JlYXRlZC4gVGhlIHJlcSBvYmplY3RcbiAgICAvLyBpcyA9PT0gdGhpcy5faGFuZGxlLCBhbmQgdGhhdCdzIHdoeSBpdCdzIGltcG9ydGFudCB0byBudWxsXG4gICAgLy8gb3V0IHRoZSB2YWx1ZXMgYWZ0ZXIgdGhleSBhcmUgZG9uZSBiZWluZyB1c2VkLiBgdGhpcy5faGFuZGxlYFxuICAgIC8vIGNhbiBzdGF5IGluIG1lbW9yeSBsb25nZXIgdGhhbiB0aGUgY2FsbGJhY2sgYW5kIGJ1ZmZlciBhcmUgbmVlZGVkLlxuICAgIGlmICh0aGlzKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpIHJldHVybjtcblxuICAgIHZhciBoYXZlID0gYXZhaWxPdXRCZWZvcmUgLSBhdmFpbE91dEFmdGVyO1xuICAgIGFzc2VydChoYXZlID49IDAsICdoYXZlIHNob3VsZCBub3QgZ28gZG93bicpO1xuXG4gICAgaWYgKGhhdmUgPiAwKSB7XG4gICAgICB2YXIgb3V0ID0gc2VsZi5fYnVmZmVyLnNsaWNlKHNlbGYuX29mZnNldCwgc2VsZi5fb2Zmc2V0ICsgaGF2ZSk7XG4gICAgICBzZWxmLl9vZmZzZXQgKz0gaGF2ZTtcbiAgICAgIC8vIHNlcnZlIHNvbWUgb3V0cHV0IHRvIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChhc3luYykge1xuICAgICAgICBzZWxmLnB1c2gob3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChvdXQpO1xuICAgICAgICBucmVhZCArPSBvdXQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4aGF1c3RlZCB0aGUgb3V0cHV0IGJ1ZmZlciwgb3IgdXNlZCBhbGwgdGhlIGlucHV0IGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDAgfHwgc2VsZi5fb2Zmc2V0ID49IHNlbGYuX2NodW5rU2l6ZSkge1xuICAgICAgYXZhaWxPdXRCZWZvcmUgPSBzZWxmLl9jaHVua1NpemU7XG4gICAgICBzZWxmLl9vZmZzZXQgPSAwO1xuICAgICAgc2VsZi5fYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDApIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSBkb25lLiAgTmVlZCB0byByZXByb2Nlc3MuXG4gICAgICAvLyBBbHNvLCB1cGRhdGUgdGhlIGF2YWlsSW5CZWZvcmUgdG8gdGhlIGF2YWlsSW5BZnRlciB2YWx1ZSxcbiAgICAgIC8vIHNvIHRoYXQgaWYgd2UgaGF2ZSB0byBoaXQgaXQgYSB0aGlyZCAoZm91cnRoLCBldGMuKSB0aW1lLFxuICAgICAgLy8gaXQnbGwgaGF2ZSB0aGUgY29ycmVjdCBieXRlIGNvdW50cy5cbiAgICAgIGluT2ZmICs9IGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXI7XG4gICAgICBhdmFpbEluQmVmb3JlID0gYXZhaWxJbkFmdGVyO1xuXG4gICAgICBpZiAoIWFzeW5jKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgdmFyIG5ld1JlcSA9IHNlbGYuX2hhbmRsZS53cml0ZShmbHVzaEZsYWcsIGNodW5rLCBpbk9mZiwgYXZhaWxJbkJlZm9yZSwgc2VsZi5fYnVmZmVyLCBzZWxmLl9vZmZzZXQsIHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgICBuZXdSZXEuY2FsbGJhY2sgPSBjYWxsYmFjazsgLy8gdGhpcyBzYW1lIGZ1bmN0aW9uXG4gICAgICBuZXdSZXEuYnVmZmVyID0gY2h1bms7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhc3luYykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZmluaXNoZWQgd2l0aCB0aGUgY2h1bmsuXG4gICAgY2IoKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhEZWZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd6aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHdW56aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhEZWZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKFVuemlwLCBabGliKTsiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBjYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5XG4gICAgLnN1YnN0cmluZyg2KVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7IHJldHVybiBrLnRvVXBwZXJDYXNlKCkgfSk7XG5cbiAgLy8gY29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuICBpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSB0cnVlO1xuICBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gZmFsc2U7XG4gIGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB2YWwgPSBudWxsO1xuICBlbHNlIHZhbCA9IE51bWJlcih2YWwpO1xuXG4gIG9ialtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBUaGUgZmlsZSBkZXNjcmlwdG9yIHRvIHdyaXRlIHRoZSBgZGVidWcoKWAgY2FsbHMgdG8uXG4gKiBTZXQgdGhlIGBERUJVR19GRGAgZW52IHZhcmlhYmxlIHRvIG92ZXJyaWRlIHdpdGggYW5vdGhlciB2YWx1ZS4gaS5lLjpcbiAqXG4gKiAgICQgREVCVUdfRkQ9MyBub2RlIHNjcmlwdC5qcyAzPmRlYnVnLmxvZ1xuICovXG5cbnZhciBmZCA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkRFQlVHX0ZELCAxMCkgfHwgMjtcblxuaWYgKDEgIT09IGZkICYmIDIgIT09IGZkKSB7XG4gIHV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uKCl7fSwgJ2V4Y2VwdCBmb3Igc3RkZXJyKDIpIGFuZCBzdGRvdXQoMSksIGFueSBvdGhlciB1c2FnZSBvZiBERUJVR19GRCBpcyBkZXByZWNhdGVkLiBPdmVycmlkZSBkZWJ1Zy5sb2cgaWYgeW91IHdhbnQgdG8gdXNlIGEgZGlmZmVyZW50IGxvZyBmdW5jdGlvbiAoaHR0cHM6Ly9naXQuaW8vZGVidWdfZmQpJykoKVxufVxuXG52YXIgc3RyZWFtID0gMSA9PT0gZmQgPyBwcm9jZXNzLnN0ZG91dCA6XG4gICAgICAgICAgICAgMiA9PT0gZmQgPyBwcm9jZXNzLnN0ZGVyciA6XG4gICAgICAgICAgICAgY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbShmZCk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgcmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHNcbiAgICA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpXG4gICAgOiB0dHkuaXNhdHR5KGZkKTtcbn1cblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcbiAgICAuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpXG4gICAgfSkuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWVzcGFjZTtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGlmICh1c2VDb2xvcnMpIHtcbiAgICB2YXIgYyA9IHRoaXMuY29sb3I7XG4gICAgdmFyIHByZWZpeCA9ICcgIFxcdTAwMWJbMycgKyBjICsgJzsxbScgKyBuYW1lICsgJyAnICsgJ1xcdTAwMWJbMG0nO1xuXG4gICAgYXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuICAgIGFyZ3MucHVzaCgnXFx1MDAxYlszJyArIGMgKyAnbSsnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMWJbMG0nKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gbmV3IERhdGUoKS50b1VUQ1N0cmluZygpXG4gICAgICArICcgJyArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuICB9XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIGBzdHJlYW1gLlxuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZSh1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBgbm9kZS9zcmMvbm9kZS5qc2AuXG4gKlxuICogWFhYOiBJdCdzIGxhbWUgdGhhdCBub2RlIGRvZXNuJ3QgZXhwb3NlIHRoaXMgQVBJIG91dC1vZi10aGUtYm94LiBJdCBhbHNvXG4gKiByZWxpZXMgb24gdGhlIHVuZG9jdW1lbnRlZCBgdHR5X3dyYXAuZ3Vlc3NIYW5kbGVUeXBlKClgIHdoaWNoIGlzIGFsc28gbGFtZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVXcml0YWJsZVN0ZGlvU3RyZWFtIChmZCkge1xuICB2YXIgc3RyZWFtO1xuICB2YXIgdHR5X3dyYXAgPSBwcm9jZXNzLmJpbmRpbmcoJ3R0eV93cmFwJyk7XG5cbiAgLy8gTm90ZSBzdHJlYW0uX3R5cGUgaXMgdXNlZCBmb3IgdGVzdC1tb2R1bGUtbG9hZC1saXN0LmpzXG5cbiAgc3dpdGNoICh0dHlfd3JhcC5ndWVzc0hhbmRsZVR5cGUoZmQpKSB7XG4gICAgY2FzZSAnVFRZJzpcbiAgICAgIHN0cmVhbSA9IG5ldyB0dHkuV3JpdGVTdHJlYW0oZmQpO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ3R0eSc7XG5cbiAgICAgIC8vIEhhY2sgdG8gaGF2ZSBzdHJlYW0gbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgYWxpdmUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzI2XG4gICAgICBpZiAoc3RyZWFtLl9oYW5kbGUgJiYgc3RyZWFtLl9oYW5kbGUudW5yZWYpIHtcbiAgICAgICAgc3RyZWFtLl9oYW5kbGUudW5yZWYoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRklMRSc6XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgc3RyZWFtID0gbmV3IGZzLlN5bmNXcml0ZVN0cmVhbShmZCwgeyBhdXRvQ2xvc2U6IGZhbHNlIH0pO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ2ZzJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUElQRSc6XG4gICAgY2FzZSAnVENQJzpcbiAgICAgIHZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBuZXQuU29ja2V0KHtcbiAgICAgICAgZmQ6IGZkLFxuICAgICAgICByZWFkYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgLy8gRklYTUUgU2hvdWxkIHByb2JhYmx5IGhhdmUgYW4gb3B0aW9uIGluIG5ldC5Tb2NrZXQgdG8gY3JlYXRlIGFcbiAgICAgIC8vIHN0cmVhbSBmcm9tIGFuIGV4aXN0aW5nIGZkIHdoaWNoIGlzIHdyaXRhYmxlIG9ubHkuIEJ1dCBmb3Igbm93XG4gICAgICAvLyB3ZSdsbCBqdXN0IGFkZCB0aGlzIGhhY2sgYW5kIHNldCB0aGUgYHJlYWRhYmxlYCBtZW1iZXIgdG8gZmFsc2UuXG4gICAgICAvLyBUZXN0OiAuL25vZGUgdGVzdC9maXh0dXJlcy9lY2hvLmpzIDwgL2V0Yy9wYXNzd2RcbiAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlYWQgPSBudWxsO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ3BpcGUnO1xuXG4gICAgICAvLyBGSVhNRSBIYWNrIHRvIGhhdmUgc3RyZWFtIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIGFsaXZlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcyNlxuICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmIHN0cmVhbS5faGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBQcm9iYWJseSBhbiBlcnJvciBvbiBpbiB1dl9ndWVzc19oYW5kbGUoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBsZW1lbnQgbWUuIFVua25vd24gc3RyZWFtIGZpbGUgdHlwZSEnKTtcbiAgfVxuXG4gIC8vIEZvciBzdXBwb3J0aW5nIGxlZ2FjeSBBUEkgd2UgcHV0IHRoZSBGRCBoZXJlLlxuICBzdHJlYW0uZmQgPSBmZDtcblxuICBzdHJlYW0uX2lzU3RkaW8gPSB0cnVlO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdCAoZGVidWcpIHtcbiAgZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYHByb2Nlc3MuZW52LkRFQlVHYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwidmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xudmFyIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKFwic3RyZWFtXCIpLldyaXRhYmxlO1xudmFyIGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwiZm9sbG93LXJlZGlyZWN0c1wiKTtcblxuLy8gUkZDNzIzMcKnNC4yLjE6IE9mIHRoZSByZXF1ZXN0IG1ldGhvZHMgZGVmaW5lZCBieSB0aGlzIHNwZWNpZmljYXRpb24sXG4vLyB0aGUgR0VULCBIRUFELCBPUFRJT05TLCBhbmQgVFJBQ0UgbWV0aG9kcyBhcmUgZGVmaW5lZCB0byBiZSBzYWZlLlxudmFyIFNBRkVfTUVUSE9EUyA9IHsgR0VUOiB0cnVlLCBIRUFEOiB0cnVlLCBPUFRJT05TOiB0cnVlLCBUUkFDRTogdHJ1ZSB9O1xuXG4vLyBDcmVhdGUgaGFuZGxlcnMgdGhhdCBwYXNzIGV2ZW50cyBmcm9tIG5hdGl2ZSByZXF1ZXN0c1xudmFyIGV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuW1wiYWJvcnRcIiwgXCJhYm9ydGVkXCIsIFwiZXJyb3JcIiwgXCJzb2NrZXRcIiwgXCJ0aW1lb3V0XCJdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGV2ZW50SGFuZGxlcnNbZXZlbnRdID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHRoaXMuX3JlZGlyZWN0YWJsZS5lbWl0KGV2ZW50LCBhcmcpO1xuICB9O1xufSk7XG5cbi8vIEFuIEhUVFAoUykgcmVxdWVzdCB0aGF0IGNhbiBiZSByZWRpcmVjdGVkXG5mdW5jdGlvbiBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVxdWVzdFxuICBXcml0YWJsZS5jYWxsKHRoaXMpO1xuICBvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLl9yZWRpcmVjdENvdW50ID0gMDtcbiAgdGhpcy5fcmVkaXJlY3RzID0gW107XG4gIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoID0gMDtcbiAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG5cbiAgLy8gU2luY2UgaHR0cC5yZXF1ZXN0IHRyZWF0cyBob3N0IGFzIGFuIGFsaWFzIG9mIGhvc3RuYW1lLFxuICAvLyBidXQgdGhlIHVybCBtb2R1bGUgaW50ZXJwcmV0cyBob3N0IGFzIGhvc3RuYW1lIHBsdXMgcG9ydCxcbiAgLy8gZWxpbWluYXRlIHRoZSBob3N0IHByb3BlcnR5IHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAgaWYgKG9wdGlvbnMuaG9zdCkge1xuICAgIC8vIFVzZSBob3N0bmFtZSBpZiBzZXQsIGJlY2F1c2UgaXQgaGFzIHByZWNlZGVuY2VcbiAgICBpZiAoIW9wdGlvbnMuaG9zdG5hbWUpIHtcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBvcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICAvLyBBdHRhY2ggYSBjYWxsYmFjayBpZiBwYXNzZWRcbiAgaWYgKHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICB0aGlzLm9uKFwicmVzcG9uc2VcIiwgcmVzcG9uc2VDYWxsYmFjayk7XG4gIH1cblxuICAvLyBSZWFjdCB0byByZXNwb25zZXMgb2YgbmF0aXZlIHJlcXVlc3RzXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fb25OYXRpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHNlbGYuX3Byb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XG4gIH07XG5cbiAgLy8gQ29tcGxldGUgdGhlIFVSTCBvYmplY3Qgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKCFvcHRpb25zLnBhdGhuYW1lICYmIG9wdGlvbnMucGF0aCkge1xuICAgIHZhciBzZWFyY2hQb3MgPSBvcHRpb25zLnBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaFBvcyA8IDApIHtcbiAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoMCwgc2VhcmNoUG9zKTtcbiAgICAgIG9wdGlvbnMuc2VhcmNoID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZyhzZWFyY2hQb3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBlcmZvcm0gdGhlIGZpcnN0IHJlcXVlc3RcbiAgdGhpcy5fcGVyZm9ybVJlcXVlc3QoKTtcbn1cblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4vLyBXcml0ZXMgYnVmZmVyZWQgZGF0YSB0byB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIC8vIFZhbGlkYXRlIGlucHV0IGFuZCBzaGlmdCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxuICBpZiAoISh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAoXCJsZW5ndGhcIiBpbiBkYXRhKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIHNob3VsZCBiZSBhIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICAvLyBJZ25vcmUgZW1wdHkgYnVmZmVycywgc2luY2Ugd3JpdGluZyB0aGVtIGRvZXNuJ3QgaW52b2tlIHRoZSBjYWxsYmFja1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzIyMDY2XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE9ubHkgd3JpdGUgd2hlbiB3ZSBkb24ndCBleGNlZWQgdGhlIG1heGltdW0gYm9keSBsZW5ndGhcbiAgaWYgKHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoICsgZGF0YS5sZW5ndGggPD0gdGhpcy5fb3B0aW9ucy5tYXhCb2R5TGVuZ3RoKSB7XG4gICAgdGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzLnB1c2goeyBkYXRhOiBkYXRhLCBlbmNvZGluZzogZW5jb2RpbmcgfSk7XG4gICAgdGhpcy5fY3VycmVudFJlcXVlc3Qud3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgfVxuICAvLyBFcnJvciB3aGVuIHdlIGV4Y2VlZCB0aGUgbWF4aW11bSBib2R5IGxlbmd0aFxuICBlbHNlIHtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJSZXF1ZXN0IGJvZHkgbGFyZ2VyIHRoYW4gbWF4Qm9keUxlbmd0aCBsaW1pdFwiKSk7XG4gICAgdGhpcy5hYm9ydCgpO1xuICB9XG59O1xuXG4vLyBFbmRzIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIC8vIFNoaWZ0IHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgIGRhdGEgPSBlbmNvZGluZyA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIC8vIFdyaXRlIGRhdGEgYW5kIGVuZFxuICB2YXIgY3VycmVudFJlcXVlc3QgPSB0aGlzLl9jdXJyZW50UmVxdWVzdDtcbiAgdGhpcy53cml0ZShkYXRhIHx8IFwiXCIsIGVuY29kaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudFJlcXVlc3QuZW5kKG51bGwsIG51bGwsIGNhbGxiYWNrKTtcbiAgfSk7XG59O1xuXG4vLyBTZXRzIGEgaGVhZGVyIHZhbHVlIG9uIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fb3B0aW9ucy5oZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LnNldEhlYWRlcihuYW1lLCB2YWx1ZSk7XG59O1xuXG4vLyBDbGVhcnMgYSBoZWFkZXIgdmFsdWUgb24gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLl9vcHRpb25zLmhlYWRlcnNbbmFtZV07XG4gIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LnJlbW92ZUhlYWRlcihuYW1lKTtcbn07XG5cbi8vIFByb3h5IGFsbCBvdGhlciBwdWJsaWMgQ2xpZW50UmVxdWVzdCBtZXRob2RzXG5bXG4gIFwiYWJvcnRcIiwgXCJmbHVzaEhlYWRlcnNcIiwgXCJnZXRIZWFkZXJcIixcbiAgXCJzZXROb0RlbGF5XCIsIFwic2V0U29ja2V0S2VlcEFsaXZlXCIsIFwic2V0VGltZW91dFwiLFxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXF1ZXN0W21ldGhvZF0oYSwgYik7XG4gIH07XG59KTtcblxuLy8gUHJveHkgYWxsIHB1YmxpYyBDbGllbnRSZXF1ZXN0IHByb3BlcnRpZXNcbltcImFib3J0ZWRcIiwgXCJjb25uZWN0aW9uXCIsIFwic29ja2V0XCJdLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZSwgcHJvcGVydHksIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXF1ZXN0W3Byb3BlcnR5XTsgfSxcbiAgfSk7XG59KTtcblxuLy8gRXhlY3V0ZXMgdGhlIG5leHQgbmF0aXZlIHJlcXVlc3QgKGluaXRpYWwgb3IgcmVkaXJlY3QpXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fcGVyZm9ybVJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIExvYWQgdGhlIG5hdGl2ZSBwcm90b2NvbFxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLl9vcHRpb25zLnByb3RvY29sO1xuICB2YXIgbmF0aXZlUHJvdG9jb2wgPSB0aGlzLl9vcHRpb25zLm5hdGl2ZVByb3RvY29sc1twcm90b2NvbF07XG4gIGlmICghbmF0aXZlUHJvdG9jb2wpIHtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwcm90b2NvbCBcIiArIHByb3RvY29sKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB1c2UgdGhlIGFnZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3RvY29sXG4gIC8vIChIVFRQIGFuZCBIVFRQUyB1c2UgZGlmZmVyZW50IHR5cGVzIG9mIGFnZW50cylcbiAgaWYgKHRoaXMuX29wdGlvbnMuYWdlbnRzKSB7XG4gICAgdmFyIHNjaGVtZSA9IHByb3RvY29sLnN1YnN0cigwLCBwcm90b2NvbC5sZW5ndGggLSAxKTtcbiAgICB0aGlzLl9vcHRpb25zLmFnZW50ID0gdGhpcy5fb3B0aW9ucy5hZ2VudHNbc2NoZW1lXTtcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbmF0aXZlIHJlcXVlc3RcbiAgdmFyIHJlcXVlc3QgPSB0aGlzLl9jdXJyZW50UmVxdWVzdCA9XG4gICAgICAgIG5hdGl2ZVByb3RvY29sLnJlcXVlc3QodGhpcy5fb3B0aW9ucywgdGhpcy5fb25OYXRpdmVSZXNwb25zZSk7XG4gIHRoaXMuX2N1cnJlbnRVcmwgPSB1cmwuZm9ybWF0KHRoaXMuX29wdGlvbnMpO1xuXG4gIC8vIFNldCB1cCBldmVudCBoYW5kbGVyc1xuICByZXF1ZXN0Ll9yZWRpcmVjdGFibGUgPSB0aGlzO1xuICBmb3IgKHZhciBldmVudCBpbiBldmVudEhhbmRsZXJzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIHJlcXVlc3Qub24oZXZlbnQsIGV2ZW50SGFuZGxlcnNbZXZlbnRdKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmQgYSByZWRpcmVjdGVkIHJlcXVlc3RcbiAgLy8gKFRoZSBmaXJzdCByZXF1ZXN0IG11c3QgYmUgZW5kZWQgZXhwbGljaXRseSB3aXRoIFJlZGlyZWN0YWJsZVJlcXVlc3QjZW5kKVxuICBpZiAodGhpcy5faXNSZWRpcmVjdCkge1xuICAgIC8vIFdyaXRlIHRoZSByZXF1ZXN0IGVudGl0eSBhbmQgZW5kLlxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYnVmZmVycyA9IHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycztcbiAgICAoZnVuY3Rpb24gd3JpdGVOZXh0KCkge1xuICAgICAgaWYgKGkgPCBidWZmZXJzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpKytdO1xuICAgICAgICByZXF1ZXN0LndyaXRlKGJ1ZmZlci5kYXRhLCBidWZmZXIuZW5jb2RpbmcsIHdyaXRlTmV4dCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KCkpO1xuICB9XG59O1xuXG4vLyBQcm9jZXNzZXMgYSByZXNwb25zZSBmcm9tIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIC8vIFN0b3JlIHRoZSByZWRpcmVjdGVkIHJlc3BvbnNlXG4gIGlmICh0aGlzLl9vcHRpb25zLnRyYWNrUmVkaXJlY3RzKSB7XG4gICAgdGhpcy5fcmVkaXJlY3RzLnB1c2goe1xuICAgICAgdXJsOiB0aGlzLl9jdXJyZW50VXJsLFxuICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgfSk7XG4gIH1cblxuICAvLyBSRkM3MjMxwqc2LjQ6IFRoZSAzeHggKFJlZGlyZWN0aW9uKSBjbGFzcyBvZiBzdGF0dXMgY29kZSBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBmdXJ0aGVyIGFjdGlvbiBuZWVkcyB0byBiZSB0YWtlbiBieSB0aGUgdXNlciBhZ2VudCBpbiBvcmRlciB0b1xuICAvLyBmdWxmaWxsIHRoZSByZXF1ZXN0LiBJZiBhIExvY2F0aW9uIGhlYWRlciBmaWVsZCBpcyBwcm92aWRlZCxcbiAgLy8gdGhlIHVzZXIgYWdlbnQgTUFZIGF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaXRzIHJlcXVlc3QgdG8gdGhlIFVSSVxuICAvLyByZWZlcmVuY2VkIGJ5IHRoZSBMb2NhdGlvbiBmaWVsZCB2YWx1ZSxcbiAgLy8gZXZlbiBpZiB0aGUgc3BlY2lmaWMgc3RhdHVzIGNvZGUgaXMgbm90IHVuZGVyc3Rvb2QuXG4gIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gIGlmIChsb2NhdGlvbiAmJiB0aGlzLl9vcHRpb25zLmZvbGxvd1JlZGlyZWN0cyAhPT0gZmFsc2UgJiZcbiAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPCA0MDApIHtcbiAgICAvLyBSRkM3MjMxwqc2LjQ6IEEgY2xpZW50IFNIT1VMRCBkZXRlY3QgYW5kIGludGVydmVuZVxuICAgIC8vIGluIGN5Y2xpY2FsIHJlZGlyZWN0aW9ucyAoaS5lLiwgXCJpbmZpbml0ZVwiIHJlZGlyZWN0aW9uIGxvb3BzKS5cbiAgICBpZiAoKyt0aGlzLl9yZWRpcmVjdENvdW50ID4gdGhpcy5fb3B0aW9ucy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBFcnJvcihcIk1heCByZWRpcmVjdHMgZXhjZWVkZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSRkM3MjMxwqc2LjQ6IEF1dG9tYXRpYyByZWRpcmVjdGlvbiBuZWVkcyB0byBkb25lIHdpdGhcbiAgICAvLyBjYXJlIGZvciBtZXRob2RzIG5vdCBrbm93biB0byBiZSBzYWZlIFvigKZdLFxuICAgIC8vIHNpbmNlIHRoZSB1c2VyIG1pZ2h0IG5vdCB3aXNoIHRvIHJlZGlyZWN0IGFuIHVuc2FmZSByZXF1ZXN0LlxuICAgIC8vIFJGQzcyMzHCpzYuNC43OiBUaGUgMzA3IChUZW1wb3JhcnkgUmVkaXJlY3QpIHN0YXR1cyBjb2RlIGluZGljYXRlc1xuICAgIC8vIHRoYXQgdGhlIHRhcmdldCByZXNvdXJjZSByZXNpZGVzIHRlbXBvcmFyaWx5IHVuZGVyIGEgZGlmZmVyZW50IFVSSVxuICAgIC8vIGFuZCB0aGUgdXNlciBhZ2VudCBNVVNUIE5PVCBjaGFuZ2UgdGhlIHJlcXVlc3QgbWV0aG9kXG4gICAgLy8gaWYgaXQgcGVyZm9ybXMgYW4gYXV0b21hdGljIHJlZGlyZWN0aW9uIHRvIHRoYXQgVVJJLlxuICAgIHZhciBoZWFkZXI7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLl9vcHRpb25zLmhlYWRlcnM7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDMwNyAmJiAhKHRoaXMuX29wdGlvbnMubWV0aG9kIGluIFNBRkVfTUVUSE9EUykpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgIC8vIERyb3AgYSBwb3NzaWJsZSBlbnRpdHkgYW5kIGhlYWRlcnMgcmVsYXRlZCB0byBpdFxuICAgICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG4gICAgICBmb3IgKGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmICgvXmNvbnRlbnQtL2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyb3AgdGhlIEhvc3QgaGVhZGVyLCBhcyB0aGUgcmVkaXJlY3QgbWlnaHQgbGVhZCB0byBhIGRpZmZlcmVudCBob3N0XG4gICAgaWYgKCF0aGlzLl9pc1JlZGlyZWN0KSB7XG4gICAgICBmb3IgKGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmICgvXmhvc3QkL2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gdGhlIHJlZGlyZWN0ZWQgcmVxdWVzdFxuICAgIHZhciByZWRpcmVjdFVybCA9IHVybC5yZXNvbHZlKHRoaXMuX2N1cnJlbnRVcmwsIGxvY2F0aW9uKTtcbiAgICBkZWJ1ZyhcInJlZGlyZWN0aW5nIHRvXCIsIHJlZGlyZWN0VXJsKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIHVybC5wYXJzZShyZWRpcmVjdFVybCkpO1xuICAgIHRoaXMuX2lzUmVkaXJlY3QgPSB0cnVlO1xuICAgIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7XG5cbiAgICAvLyBEaXNjYXJkIHRoZSByZW1haW5kZXIgb2YgdGhlIHJlc3BvbnNlIHRvIGF2b2lkIHdhaXRpbmcgZm9yIGRhdGFcbiAgICByZXNwb25zZS5kZXN0cm95KCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gVGhlIHJlc3BvbnNlIGlzIG5vdCBhIHJlZGlyZWN0OyByZXR1cm4gaXQgYXMtaXNcbiAgICByZXNwb25zZS5yZXNwb25zZVVybCA9IHRoaXMuX2N1cnJlbnRVcmw7XG4gICAgcmVzcG9uc2UucmVkaXJlY3RzID0gdGhpcy5fcmVkaXJlY3RzO1xuICAgIHRoaXMuZW1pdChcInJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcblxuICAgIC8vIENsZWFuIHVwXG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG4gIH1cbn07XG5cbi8vIFdyYXBzIHRoZSBrZXkvdmFsdWUgb2JqZWN0IG9mIHByb3RvY29scyB3aXRoIHJlZGlyZWN0IGZ1bmN0aW9uYWxpdHlcbmZ1bmN0aW9uIHdyYXAocHJvdG9jb2xzKSB7XG4gIC8vIERlZmF1bHQgc2V0dGluZ3NcbiAgdmFyIGV4cG9ydHMgPSB7XG4gICAgbWF4UmVkaXJlY3RzOiAyMSxcbiAgICBtYXhCb2R5TGVuZ3RoOiAxMCAqIDEwMjQgKiAxMDI0LFxuICB9O1xuXG4gIC8vIFdyYXAgZWFjaCBwcm90b2NvbFxuICB2YXIgbmF0aXZlUHJvdG9jb2xzID0ge307XG4gIE9iamVjdC5rZXlzKHByb3RvY29scykuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgdmFyIHByb3RvY29sID0gc2NoZW1lICsgXCI6XCI7XG4gICAgdmFyIG5hdGl2ZVByb3RvY29sID0gbmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXSA9IHByb3RvY29sc1tzY2hlbWVdO1xuICAgIHZhciB3cmFwcGVkUHJvdG9jb2wgPSBleHBvcnRzW3NjaGVtZV0gPSBPYmplY3QuY3JlYXRlKG5hdGl2ZVByb3RvY29sKTtcblxuICAgIC8vIEV4ZWN1dGVzIGEgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIHdyYXBwZWRQcm90b2NvbC5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVybC5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5tYXhSZWRpcmVjdHMgPSBleHBvcnRzLm1heFJlZGlyZWN0cztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgICAgICAgIG1heFJlZGlyZWN0czogZXhwb3J0cy5tYXhSZWRpcmVjdHMsXG4gICAgICAgICAgbWF4Qm9keUxlbmd0aDogZXhwb3J0cy5tYXhCb2R5TGVuZ3RoLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMubmF0aXZlUHJvdG9jb2xzID0gbmF0aXZlUHJvdG9jb2xzO1xuICAgICAgYXNzZXJ0LmVxdWFsKG9wdGlvbnMucHJvdG9jb2wsIHByb3RvY29sLCBcInByb3RvY29sIG1pc21hdGNoXCIpO1xuICAgICAgZGVidWcoXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG5ldyBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gRXhlY3V0ZXMgYSBHRVQgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIHdyYXBwZWRQcm90b2NvbC5nZXQgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gd3JhcHBlZFByb3RvY29sLnJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZXhwb3J0cztcbn1cblxuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB3cmFwKHsgaHR0cDogaHR0cCwgaHR0cHM6IGh0dHBzIH0pO1xubW9kdWxlLmV4cG9ydHMud3JhcCA9IHdyYXA7XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwcyA9IG1vZHVsZS5leHBvcnRzXG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gIGlmIChodHRwLmhhc093blByb3BlcnR5KGtleSkpIGh0dHBzW2tleV0gPSBodHRwW2tleV1cbn1cblxuaHR0cHMucmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gIHBhcmFtcyA9IHZhbGlkYXRlUGFyYW1zKHBhcmFtcylcbiAgcmV0dXJuIGh0dHAucmVxdWVzdC5jYWxsKHRoaXMsIHBhcmFtcywgY2IpXG59XG5cbmh0dHBzLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gIHBhcmFtcyA9IHZhbGlkYXRlUGFyYW1zKHBhcmFtcylcbiAgcmV0dXJuIGh0dHAuZ2V0LmNhbGwodGhpcywgcGFyYW1zLCBjYilcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYXJhbXMgKHBhcmFtcykge1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICB9XG4gIGlmICghcGFyYW1zLnByb3RvY29sKSB7XG4gICAgcGFyYW1zLnByb3RvY29sID0gJ2h0dHBzOidcbiAgfVxuICBpZiAocGFyYW1zLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgXCInICsgcGFyYW1zLnByb3RvY29sICsgJ1wiIG5vdCBzdXBwb3J0ZWQuIEV4cGVjdGVkIFwiaHR0cHM6XCInKVxuICB9XG4gIHJldHVybiBwYXJhbXNcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInRyeSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIHV0aWwuaW5oZXJpdHMgIT09ICdmdW5jdGlvbicpIHRocm93ICcnO1xuICBtb2R1bGUuZXhwb3J0cyA9IHV0aWwuaW5oZXJpdHM7XG59IGNhdGNoIChlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbmhlcml0c19icm93c2VyLmpzJyk7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMyBTbGVlcGxlc3MgU29mdHdhcmUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbnJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG5JTiBUSEUgU09GVFdBUkUuIFxuKi9cblxuLy8geWVzLCBJIGtub3cgdGhpcyBzZWVtcyBzdHVwaWQsIGJ1dCBJIGhhdmUgbXkgcmVhc29ucy5cblxudmFyIG5ldCA9IHJlcXVpcmUoXCJuZXRcIilcbmZvcihrIGluIG5ldClcblx0Z2xvYmFsW2tdID0gbmV0W2tdXG5cbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnIGluc3RhbmNlb2YgQnVmZmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbCwgcmV0KSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLCByZWosIGNiKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59KTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbmQuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWcgPSByZXF1aXJlKCd1dGlsJyk7XG5pZiAoZGVidWcgJiYgZGVidWcuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChpc05hTihuKSB8fCB1dGlsLmlzTnVsbChuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKCF1dGlsLmlzTnVtYmVyKG4pIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHV0aWwuaXNOdWxsKHJldCkpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbChyZXQpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJyxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICAgICAgICAgIHNlbGYucmVhZCgwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgfVxuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcbiAgfVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbihzdHJlYW1baV0pICYmIHV0aWwuaXNVbmRlZmluZWQodGhpc1tpXSkpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGRhdGEpKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbih0aGlzLl9mbHVzaCkpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHRzLndyaXRlY2h1bmspICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihjYikpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHV0aWwuaXNTdHJpbmcoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KVxuICAgIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtcbiAgZWxzZVxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgZWxzZSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXIpO1xuICB9XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGggPiAxKSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBjYnMgPSBbXTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKylcbiAgICAgIGNicy5wdXNoKHN0YXRlLmJ1ZmZlcltjXS5jYWxsYmFjayk7XG5cbiAgICAvLyBjb3VudCB0aGUgb25lIHdlIGFyZSBhZGRpbmcsIGFzIHdlbGwuXG4gICAgLy8gVE9ETyhpc2FhY3MpIGNsZWFuIHRoaXMgdXBcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgc3RhdGUuYnVmZmVyLCAnJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgICAgY2JzW2ldKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbGVhciBidWZmZXJcbiAgICBzdGF0ZS5idWZmZXIgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGMrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGggPSAwO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcblxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oY2h1bmspKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2VcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5pZiAoIXByb2Nlc3MuYnJvd3NlciAmJiBwcm9jZXNzLmVudi5SRUFEQUJMRV9TVFJFQU0gPT09ICdkaXNhYmxlJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiZXhwb3J0IGxldCBBUElfRU5EUE9JTlQgPSBcImh0dHBzOi8vY2xvdWQuc2NobXVja2xpLm5ldC9jbGllbnRfYXBpL3YxL2F1dGgvXCI7XG4iLCJpbXBvcnQgKiBhcyBDb25maWcgZnJvbSBcIi4vY29uZmlnXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5cbmNsYXNzIHNDQXV0aCB7XG4gIC8qKlxuICBPcGVucyBhIG5ldyBzY2htdWNrbGlDbG91ZCBhdXRoZW50aWNhdGlvbiBpbnN0YW5jZS4gSXQgY2FuIGJlIHVzZWQgdG8gbWFuYWdlIHRoZW4gYWxsIHRoZSBkYXRhIGluIGEgZGVmaW5lZCBwcm9qZWN0LlxuICBAcGFyYW0ge1N0cmluZ30gYXBwX2lkIFRoZSBBUFAgSUQsIHdoaWNoIHdhcyBjcmVhdGVkIGZvciBhIGNsaWVudCBhcHAgaW4gdGhlIHNjaG11Y2tsaUNsb3VkIGNvbnNvbGUuXG4gIEBwYXJhbSB7U3RyaW5nfSBhcHBfc2VjcmV0IFRoZSBBUFAgU2VjcmV0LCB3aGljaCB3YXMgY3JlYXRlZCBmb3IgYSBjbGllbnQgYXBwIGluIHRoZSBzY2htdWNrbGlDbG91ZCBjb25zb2xlLlxuICAqL1xuICBjb25zdHJ1Y3RvcihhcHBfaWQsIGFwcF9zZWNyZXQpIHtcbiAgICB0aGlzLmFwcGlkID0gYXBwX2lkO1xuICAgIHRoaXMuYXBwc2VjcmV0ID0gYXBwX3NlY3JldDtcbiAgfVxuXG4gIC8qXG4gIC0tLS0tLS0tLSBFbWFpbCBQYXNzd29yZCBQcm92aWRlciAtLS0tLS0tLS1cbiAgKi9cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyB1c2VyIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBzeXN0ZW0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbCBUaGUgbmV3IGVtYWlsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgbmV3IHBhc3N3b3JkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBBIHR3byBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSAoZXguIGRlLCBlbilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBhc3luYyByZWdpc3RlckVtYWlsUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkLCBsYW5ndWFnZSkge1xuICAgIHZhciBnbG9iYWxfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXhpb3Moe1xuICAgICAgICB1cmw6IENvbmZpZy5BUElfRU5EUE9JTlQgKyBcImVtYWlscGFzc3dvcmQucGhwXCIsXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgYXBwc2VjcmV0OiBnbG9iYWxfdGhpcy5hcHBzZWNyZXRcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVtYWlsOiBlbWFpbCxcbiAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2VcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IHNDUmVzdWx0KGRhdGEuc3RhdHVzLCBkYXRhLm1lc3NhZ2UsIGRhdGEuYm9keSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgcmVnaXN0ZXJpbmcgdGhlIHVzZXIgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQuIEZvbGxvd2luZyBlcnJvciBtZXNzYWdlOiBcIiArXG4gICAgICAgICAgICAgICAgZGF0YS5tZXNzYWdlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXV0aG9yaXplcyB0aGUgdXNlciB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZC4gSW4gdGhlIGJvZHkgeW91IHdpbGwgZmluZCB0aGUgc2Vzc2lvbiB0b2tlbixcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsIFRoZSBlbWFpbCBvZiB0aGUgdXNlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIG9mIHRoZSB1c2VyXG4gICAqIEByZXR1cm5zIHtzQ1Jlc3VsdH0gSWYgaXQgd2FzIHN1Y2Nlc3NmdWwsIGl0IHdpbGwgcHJvdmlkZSB0aGUgc2Vzc2lvbiB0b2tlbiBpbiB0aGUgYm9keS4gU2F2ZSBpdCBzb21ld2hlcmUgc2F2ZSBvbiB0aGUgY2xpZW50LlxuICAgKi9cbiAgYXN5bmMgYXV0aG9yaXplRW1haWxQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICB2YXIgZ2xvYmFsX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGF4aW9zKHtcbiAgICAgICAgdXJsOiBDb25maWcuQVBJX0VORFBPSU5UICsgXCJlbWFpbHBhc3N3b3JkLnBocFwiLFxuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgYXBwc2VjcmV0OiBnbG9iYWxfdGhpcy5hcHBzZWNyZXRcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVtYWlsOiBlbWFpbCxcbiAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IHNDUmVzdWx0KGRhdGEuc3RhdHVzLCBkYXRhLm1lc3NhZ2UsIGRhdGEuYm9keSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgYXV0aG9yaXppbmcgdGhlIHVzZXIgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQuIEZvbGxvd2luZyBlcnJvciBtZXNzYWdlOiBcIiArXG4gICAgICAgICAgICAgICAgZGF0YS5tZXNzYWdlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHVzZXIgaGFzIGZvcmdvdHR0ZW4gaGlzIHBhc3N3b3JkLCBqdXN0IHByb3ZpZGUgdGhlIGVtYWlsIGFuZCBpdCB3aWxsIHNlbmQgYW4gZW1haWwgd2l0aCBhIHBhc3N3b3JkIGNoYW5nZSBsaW5rLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWwgVGhlIGVtYWlsIGZyb20gdGhlIGFjY291bnQgKGV4LiBFbWFpbFBhc3N3b3JkIG9yIGFueSBvdGhlciBwcm92aWRlcilcbiAgICogQHJldHVybnMge3NDUmVzdWx0fVxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdFJlc2V0UGFzc3dvcmQoZW1haWwpIHtcbiAgICB2YXIgZ2xvYmFsX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGF4aW9zKHtcbiAgICAgICAgdXJsOiBDb25maWcuQVBJX0VORFBPSU5ULFxuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgYXBwc2VjcmV0OiBnbG9iYWxfdGhpcy5hcHBzZWNyZXRcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGZ1bmN0aW9uOiBcInJlcXVlc3RfcmVzZXRfcGFzc3dvcmRcIixcbiAgICAgICAgICBlbWFpbDogZW1haWxcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IHNDUmVzdWx0KGRhdGEuc3RhdHVzLCBkYXRhLm1lc3NhZ2UsIGRhdGEuYm9keSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgcmVxdWVzdGluZyBmb3IgYSBuZXcgcGFzc3dvcmQuIEZvbGxvd2luZyBlcnJvciBtZXNzYWdlOiBcIiArXG4gICAgICAgICAgICAgICAgZGF0YS5tZXNzYWdlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGFzc3dvcmQgZm9yIHRoZSB1c2VyLCBhZnRlciBoZSBoYXMgY2xpY2tlZCB0aGUgbGluayBpbiB0aGUgcmVjZWl2ZWQgbWFpbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc2V0X3Rva2VuIFRoZSByZXNldCB0b2tlbiwgcHJvdmlkZWQgZnJvbSB0aGUgc2VudCBlbWFpbCB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIG5ldyBwYXNzd29yZCBmb3IgdGhlIHVzZXJcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJlc2V0UGFzc3dvcmQocmVzZXRfdG9rZW4sIHBhc3N3b3JkKSB7XG4gICAgdmFyIGdsb2JhbF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBheGlvcyh7XG4gICAgICAgIHVybDogQ29uZmlnLkFQSV9FTkRQT0lOVCxcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgYXBwaWQ6IGdsb2JhbF90aGlzLmFwcGlkLFxuICAgICAgICAgIGFwcHNlY3JldDogZ2xvYmFsX3RoaXMuYXBwc2VjcmV0XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBmdW5jdGlvbjogXCJ1cGRhdGVfcmVzZXRfcGFzc3dvcmRcIixcbiAgICAgICAgICB0b2tlbjogcmVzZXRfdG9rZW4sXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBzQ1Jlc3VsdChkYXRhLnN0YXR1cywgZGF0YS5tZXNzYWdlLCBkYXRhLmJvZHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHVwZGF0aW5nIHRoZSBwYXNzd29yZC4gRm9sbG93aW5nIGVycm9yIG1lc3NhZ2U6IFwiICtcbiAgICAgICAgICAgICAgICBkYXRhLm1lc3NhZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24sIGlmIHRoZSB1c2VyIGhhcyBjbGlja2VkIG9uIHRoZSBhY3RpdmF0aW9uIGxpbmsgaW4gdGhlIHdlbGNvbWUgZW1haWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgdG9rZW4sIHdoaWNoIHdhcyBnaXZlbiB0aHJvdWdoIHRoZSBwYXJhbWV0ZXIgaW4gdGhlIGVtYWlsIGxpbmsuXG4gICAqIEByZXR1cm5zIHtzQ1Jlc3VsdH0gSWYgaXQgd2FzIHN1Y2Nlc3NmdWwsIHRoZW4gaXQgd2lsbCByZXR1cm4gYSBjb25maXJtYXRpb24uXG4gICAqL1xuICBhc3luYyBhY3RpdmF0ZVVzZXIodG9rZW4pIHtcbiAgICB2YXIgZ2xvYmFsX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGF4aW9zKHtcbiAgICAgICAgdXJsOiBDb25maWcuQVBJX0VORFBPSU5ULFxuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgYXBwc2VjcmV0OiBnbG9iYWxfdGhpcy5hcHBzZWNyZXRcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGZ1bmN0aW9uOiBcImFjdGl2YXRlX2FjY291bnRcIixcbiAgICAgICAgICB0b2tlbjogdG9rZW5cbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IHNDUmVzdWx0KGRhdGEuc3RhdHVzLCBkYXRhLm1lc3NhZ2UsIGRhdGEuYm9keSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgYWN0aXZhdGluZyB0aGUgdXNlciBhY2NvdW50LiBGb2xsb3dpbmcgZXJyb3IgbWVzc2FnZTogXCIgK1xuICAgICAgICAgICAgICAgIGRhdGEubWVzc2FnZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qXG5SZXN1bHQgb2JqZWN0IGZvciBmaWx0ZXJpbmcgdGhlXG4qL1xuY2xhc3Mgc0NSZXN1bHQge1xuICBjb25zdHJ1Y3RvcihzdGF0dXNfY29kZSwgbWVzc2FnZSwgYm9keSkge1xuICAgIHRoaXMuc3RhdHVzX2NvZGUgPSBzdGF0dXNfY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGF0YSA9IGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlLCBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc09LKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1c19jb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c19jb2RlIDw9IDI5OSA/IHRydWUgOiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBzQ0F1dGgsIHNDUmVzdWx0IH07XG4iLCJleHBvcnQgbGV0IEFQSV9FTkRQT0lOVCA9IFwiaHR0cHM6Ly9jbG91ZC5zY2htdWNrbGkubmV0L2NsaWVudF9hcGkvdjEvZGF0YS9cIjtcbiIsImltcG9ydCAqIGFzIENvbmZpZyBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcblxuZXhwb3J0IGNsYXNzIHNDU3RvcmFnZSB7XG4gIC8qKlxuICBPcGVucyBhIG5ldyBzY2htdWNrbGlDbG91ZCBzdG9yYWdlIGluc3RhbmNlLiBJdCBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgdGhlbiBhbGwgdGhlIGRhdGEgaW4gYSBkZWZpbmVkIHByb2plY3QuXG4gIEBwYXJhbSB7U3RyaW5nfSBhcHBfaWQgVGhlIEFQUCBJRCwgd2hpY2ggd2FzIGNyZWF0ZWQgZm9yIGEgY2xpZW50IGFwcCBpbiB0aGUgc2NobXVja2xpQ2xvdWQgY29uc29sZS5cbiAgQHBhcmFtIHtTdHJpbmd9IGFwcF9zZWNyZXQgVGhlIEFQUCBTZWNyZXQsIHdoaWNoIHdhcyBjcmVhdGVkIGZvciBhIGNsaWVudCBhcHAgaW4gdGhlIHNjaG11Y2tsaUNsb3VkIGNvbnNvbGUuXG4gICovXG4gIGNvbnN0cnVjdG9yKGFwcF9pZCwgYXBwX3NlY3JldCkge1xuICAgIHRoaXMuYXBwaWQgPSBhcHBfaWQ7XG4gICAgdGhpcy5hcHBzZWNyZXQgPSBhcHBfc2VjcmV0O1xuICB9XG5cbiAgLyoqXG4gIFNldCB0aGUgZGF0YXNldCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBmdXJ0aGVyIGRhdGEgb3BlcmF0aW9ucy5cbiAgQHBhcmFtIHtTdHJpbmd9IGRhdGFzZXRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCAoRG8gbm90IHVzZSB0aGUgaWQpXG4gICovXG4gIHNldERhdGFzZXQoZGF0YXNldF9uYW1lKSB7XG4gICAgdGhpcy5kYXRhc2V0ID0gZGF0YXNldF9uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiB0byB0aGUgc3RvcmFnZSBvYmplY3QsIHRvIHVzZSB0aGUgcHJvdGVjdGVkIGRhdGFzZXQsIHJlc2VydmVkIGZvciB0aGUgdXNlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhfdG9rZW4gVGhlIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gdG9rZW4gZnJvbSB0aGUgYXV0aCBsaWJyYXJ5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5vdF9yZXNldCBCeSBkZWZhdWx0LCBpdCB3aWxsIHJlc2V0IHRoZSBkYXRhc2V0LiBJZiB5b3Ugd2FudCB0byB1c2UgdGhlIGF1dGhlbnRpY2F0aW9uIGRhdGFzZXQsIHlvdSBtdXN0IHByb3ZpZGUgYSBlbXB0eSBkYXRhc2V0IHN0cmluZy5cbiAgICovXG4gIHNldEF1dGhUb2tlbihhdXRoX3Rva2VuLCBub3RfcmVzZXQpe1xuICAgIHRoaXMuYXV0aF90b2tlbiA9IGF1dGhfdG9rZW47XG4gICAgaWYobm90X3Jlc2V0ID09PSBmYWxzZSB8fCBub3RfcmVzZXQgPT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLmRhdGFzZXQgPSBcIlwiO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBTZXQgdGhlIGJ1Y2tldCBpZCB3aGljaCBsYXRlciBzaG91bGQgYmUgdXNlZCB0byBtYW5hZ2UgZGF0YS5cbiAgQHBhcmFtIHtOdW1iZXJ9IGJ1Y2tldF9pZCBUaGUgbnVtYmVyIG9mIHRoZSBidWNrZXQgaWRcbiAgKi9cbiAgc2V0QnVja2V0KGJ1Y2tldF9pZCkge1xuICAgIHRoaXMuYnVja2V0X2lkID0gYnVja2V0X2lkO1xuICB9XG5cbiAgLyoqXG4gIFRoaXMgbWV0aG9kIGxldHMgeW91IHJldHJpZXZlIGFsbCByb3dzIGZyb20gYSBjb250YWluZXIuXG4gIEBwYXJhbSB7U3RyaW5nfSBjb250YWluZXJfbmFtZSBUaGUgY29udGFpbmVyIG5hbWUsIGNyZWF0ZWQgdmlhIHRoZSBzY2htdWNrbGlDbG91ZCBjb25zb2xlXG4gIEBwYXJhbSB7U3RyaW5nfSBzb3J0aW5nIFNvcnQgdGhlIGVudHJpZXMgYXNjZW5kaW5nICgnYXNjJyBieSBkZWZhdWx0KSBvciBkZXNjZW5kaW5nICgnZGVzYycpLlxuICBAcGFyYW0ge051bWJlcn0gc3RhcnQgRGVmaW5lIGEgc3RhcnQgaW5kZXguXG4gIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBEZWZpbmUgYSBtYXhpbXVtIG9mIHNob3dpbmcgcmVzdWx0cy5cbiAgQHJldHVybiB7UHJvbWlzZX0gVGhlIGZ1bmN0aW9uIHJldHVybnMgeW91IGEgcHJvbWlzZS4gWW91IGNhbiB1c2UgdGhlICd0aGVuJyBtZXRob2QsIHRvIHdhaXQgZm9yIGl0LiBBZnRlcndhcmRzIHlvdSBnZXQgdGhlIHJlc3VsdC5cbiAgKi9cbiAgZ2V0QWxsKGNvbnRhaW5lcl9uYW1lLCBzb3J0aW5nLCBzdGFydCwgbGltaXQpIHtcbiAgICB2YXIgZ2xvYmFsX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vQ2hlY2sgdGhlIHByb3BlcnRpZXMgYmVmb3JlIHNlbmRpbmcgdG8gdGhlIEFQSVxuICAgICAgaWYgKGNvbnRhaW5lcl9uYW1lID09PSB1bmRlZmluZWQgfHwgY29udGFpbmVyX25hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlBsZWFzZSBkZWZpbmUgYSBjb250YWluZXIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzb3J0aW5nKSB7XG4gICAgICAgIGlmIChzb3J0aW5nICE9PSBcImFzY1wiICYmIHNvcnRpbmcgIT09IFwiZGVzY1wiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJzY2htdWNrbGlDbG91ZCBTREs6IFRoZSBzb3J0aW5nIGlzIG5vdCBkZWNsYXJlZCBjb3JyZWNsdHkuIFBsZWFzZSB1c2UgJ2FzYycgKGRlZmF1bHQpIG9yICdkZXNjJyB0byBzb3J0IHRoZSBkYXRhLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ydGluZyA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0YXJ0ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgYXhpb3NcbiAgICAgICAgLmdldChcbiAgICAgICAgICBDb25maWcuQVBJX0VORFBPSU5UICtcbiAgICAgICAgICAgIFwiP2J1Y2tldD1cIiArXG4gICAgICAgICAgICBnbG9iYWxfdGhpcy5idWNrZXRfaWQgK1xuICAgICAgICAgICAgXCImZGF0YXNldD1cIiArXG4gICAgICAgICAgICBlbmNvZGVVUkkoZ2xvYmFsX3RoaXMuZGF0YXNldCkgK1xuICAgICAgICAgICAgXCImY29udGFpbmVyPVwiICtcbiAgICAgICAgICAgIGNvbnRhaW5lcl9uYW1lICtcbiAgICAgICAgICAgIFwiJm9yZGVyPVwiICtcbiAgICAgICAgICAgIHNvcnRpbmcgK1xuICAgICAgICAgICAgXCImc3RhcnQ9XCIgK1xuICAgICAgICAgICAgc3RhcnQgK1xuICAgICAgICAgICAgXCImbGltaXQ9XCIgK1xuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgICAgIGFwcHNlY3JldDogZ2xvYmFsX3RoaXMuYXBwc2VjcmV0LFxuICAgICAgICAgICAgICBhdXRodG9rZW46IGdsb2JhbF90aGlzLmF1dGhfdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBzQ1Jlc3VsdChcbiAgICAgICAgICAgICAgcmVzdWx0LmRhdGEuc3RhdHVzLFxuICAgICAgICAgICAgICByZXN1bHQuZGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgICByZXN1bHQuZGF0YS5ib2R5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGhlcmUgd2FzIGEgcHJvYmxlbSB3aXRoIHRoZSBBUEkgZW5kcG9pbnQuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gIFRoaXMgbWV0aG9kIGxldHMgeW91IHJldHJpZXZlIGRhdGEgd2l0aCBmaWx0ZXJzLlxuICBAcGFyYW0ge1N0cmluZ30gY29udGFpbmVyX25hbWUgVGhlIGNvbnRhaW5lciBuYW1lLCBjcmVhdGVkIHZpYSB0aGUgc2NobXVja2xpQ2xvdWQgY29uc29sZVxuICBAcGFyYW0ge0FycmF5fSBmaWx0ZXIgQSBmaWx0ZXIgaXMgYW4gYXJyYXksIGRlZmluaW5nIHdoaWNoIGVudHJpZXMgc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAgQHBhcmFtIHtTdHJpbmd9IHNvcnRpbmcgU29ydCB0aGUgZW50cmllcyBhc2NlbmRpbmcgKCdhc2MnIGJ5IGRlZmF1bHQpIG9yIGRlc2NlbmRpbmcgKCdkZXNjJykuXG4gIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBEZWZpbmUgYSBzdGFydCBpbmRleC5cbiAgQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IERlZmluZSBhIG1heGltdW0gb2Ygc2hvd2luZyByZXN1bHRzLlxuICBAcmV0dXJuIHtQcm9taXNlfSBUaGUgZnVuY3Rpb24gcmV0dXJucyB5b3UgYSBwcm9taXNlLiBZb3UgY2FuIHVzZSB0aGUgJ3RoZW4nIG1ldGhvZCwgdG8gd2FpdCBmb3IgaXQuXG4gICovXG4gIGdldChjb250YWluZXJfbmFtZSwgZmlsdGVyLCBzb3J0aW5nLCBzdGFydCwgbGltaXQpIHtcbiAgICB2YXIgZ2xvYmFsX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vQ2hlY2sgdGhlIHByb3BlcnRpZXMgYmVmb3JlIHNlbmRpbmcgdG8gdGhlIEFQSVxuICAgICAgaWYgKGNvbnRhaW5lcl9uYW1lID09PSB1bmRlZmluZWQgfHwgY29udGFpbmVyX25hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlBsZWFzZSBkZWZpbmUgYSBjb250YWluZXIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlciA9PSAwKSB7XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlBsZWFzZSBkZWZpbmUgYXQgbGVhc3Qgb25lIGNvbmRpdGlvbi4gSWYgeW91IHdhbnQgdG8gc2hvdyBhbGwgZW50cmllcywgcGxlYXNlIHVzZSB0aGUgbWV0aG9kICdnZXRBbGwnXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgY29uZGl0aW9ucy5cIikpO1xuICAgICAgfVxuICAgICAgdmFyIGVuY29kZWRGaWx0ZXIgPSBlbmNvZGVVUkkoSlNPTi5zdHJpbmdpZnkoZmlsdGVyKSk7XG5cbiAgICAgIGlmICghc29ydGluZykge1xuICAgICAgICBpZiAoc29ydGluZyAhPT0gXCJhc2NcIiAmJiBzb3J0aW5nICE9PSBcImRlc2NcIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwic2NobXVja2xpQ2xvdWQgU0RLOiBUaGUgc29ydGluZyBpcyBub3QgZGVjbGFyZWQgY29ycmVjbHR5LiBQbGVhc2UgdXNlICdhc2MnIChkZWZhdWx0KSBvciAnZGVzYycgdG8gc29ydCB0aGUgZGF0YS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvcnRpbmcgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFydCA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGF4aW9zXG4gICAgICAgIC5nZXQoXG4gICAgICAgICAgQ29uZmlnLkFQSV9FTkRQT0lOVCArXG4gICAgICAgICAgICBcIj9idWNrZXQ9XCIgK1xuICAgICAgICAgICAgZ2xvYmFsX3RoaXMuYnVja2V0X2lkICtcbiAgICAgICAgICAgIFwiJmRhdGFzZXQ9XCIgK1xuICAgICAgICAgICAgZW5jb2RlVVJJKGdsb2JhbF90aGlzLmRhdGFzZXQpICtcbiAgICAgICAgICAgIFwiJmNvbnRhaW5lcj1cIiArXG4gICAgICAgICAgICBlbmNvZGVVUkkoY29udGFpbmVyX25hbWUpICtcbiAgICAgICAgICAgIFwiJmZpbHRlcj1cIiArXG4gICAgICAgICAgICBlbmNvZGVkRmlsdGVyICtcbiAgICAgICAgICAgIFwiJm9yZGVyPVwiICtcbiAgICAgICAgICAgIHNvcnRpbmcgK1xuICAgICAgICAgICAgXCImc3RhcnQ9XCIgK1xuICAgICAgICAgICAgc3RhcnQgK1xuICAgICAgICAgICAgXCImbGltaXQ9XCIgK1xuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgICAgIGFwcHNlY3JldDogZ2xvYmFsX3RoaXMuYXBwc2VjcmV0LFxuICAgICAgICAgICAgICBhdXRodG9rZW46IGdsb2JhbF90aGlzLmF1dGhfdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBzQ1Jlc3VsdChcbiAgICAgICAgICAgICAgcmVzdWx0LmRhdGEuc3RhdHVzLFxuICAgICAgICAgICAgICByZXN1bHQuZGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgICByZXN1bHQuZGF0YS5ib2R5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhIHByb2JsZW0gd2l0aCB0aGUgQVBJIGVuZHBvaW50LiBGb2xsb3dpbmcgZXJyb3IgbWVzc2FnZSB3YXMgc2VudDogXCIgK1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEubWVzc2FnZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgVGhpcyBtZXRoZG9kIGNhbiBhZGQgbmV3IHJvd3MgdG8geW91IGNvbnRhaW5lciBpbiB0aGUgcHJldmlvdXMgc2V0IGRhdGFzZXQuXG4gIEBwYXJhbSB7U3RyaW5nfSBjb250YWluZXJfbmFtZSBUaGUgY29udGFpbmVyIG5hbWUsIGNyZWF0ZWQgdmlhIHRoZSBzY2htdWNrbGlDbG91ZCBjb25zb2xlXG4gIEBwYXJhbSB7U3RyaW5nfSBkYXRhIEEgZGF0YW9iamVjdCB3aXRoIGEga2V5LXZhbHVlIHBhaXIuIFRoZSBrZXkgcmVwcmVzZW50cyB0aGUgY29sdW1ucyBkZWZpbmVkIGluIHRoZSBzY2htdWNrbGlDbG91ZCBjb25zb2xlLlxuICBAcmV0dXJuIHtQcm9taXNlfSBUaGUgZnVuY3Rpb24gcmV0dXJucyB5b3UgYSBwcm9taXNlLiBZb3UgY2FuIHVzZSB0aGUgJ3RoZW4nIG1ldGhvZCwgdG8gd2FpdCBmb3IgaXQuIEFmdGVyd2FyZHMgeW91IGdldCBhIHRydWUgKHdoZW4gZXZlcnl0aGluZyB3YXMgZmluZSkgb3IgYW4gZXJyb3Igb2JqZWN0LlxuICAqL1xuICBpbnNlcnQoY29udGFpbmVyX25hbWUsIGRhdGEpIHtcbiAgICB2YXIgZ2xvYmFsX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vQ2hlY2sgdGhlIHByb3BlcnRpZXMgYmVmb3JlIHNlbmRpbmcgdG8gdGhlIEFQSVxuICAgICAgaWYgKGNvbnRhaW5lcl9uYW1lID09PSB1bmRlZmluZWQgfHwgY29udGFpbmVyX25hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlBsZWFzZSBkZWZpbmUgYSBjb250YWluZXIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGZpbmFsX2RhdGEgPSBcInt9XCI7XG4gICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IHt9KSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIGRhdGEgb2JqZWN0LlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbF9kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGF4aW9zKHtcbiAgICAgICAgdXJsOiBDb25maWcuQVBJX0VORFBPSU5ULFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgYXBwaWQ6IGdsb2JhbF90aGlzLmFwcGlkLFxuICAgICAgICAgIGFwcHNlY3JldDogZ2xvYmFsX3RoaXMuYXBwc2VjcmV0LFxuICAgICAgICAgIGF1dGh0b2tlbjogZ2xvYmFsX3RoaXMuYXV0aF90b2tlblxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYnVja2V0OiBnbG9iYWxfdGhpcy5idWNrZXRfaWQsXG4gICAgICAgICAgZGF0YXNldDogZW5jb2RlVVJJKGdsb2JhbF90aGlzLmRhdGFzZXQpLFxuICAgICAgICAgIGNvbnRhaW5lcjogZW5jb2RlVVJJKGNvbnRhaW5lcl9uYW1lKSxcbiAgICAgICAgICBkYXRhOiBmaW5hbF9kYXRhXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBzQ1Jlc3VsdChkYXRhLnN0YXR1cywgZGF0YS5tZXNzYWdlLCBkYXRhLmJvZHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGluc2VydGluZyBkYXRhLiBGb2xsb3dpbmcgZXJyb3IgbWVzc2FnZTogXCIgK1xuICAgICAgICAgICAgICAgIGRhdGEubWVzc2FnZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gIFRoaXMgbWV0aG9kIHVwZGF0ZXMgYSBzcGVjaWZpYyByb3cgaW4gYSBjb250YWluZXJcbiAgQHBhcmFtIHtTdHJpbmd9IGNvbnRhaW5lcl9uYW1lIERlZmluZSBhIGNvbnRhaW5lciBuYW1lLCB3aGljaCBzaG91bGQgYmUgdXBkYXRlZC5cbiAgQHBhcmFtIHtOdW1iZXJ9IHJvd19pZCBEZWZpbmUgYSByb3cgaWQgd2hpY2ggc2hvdWxkIGJlIHVwZGF0ZWRcbiAgQHBhcmFtIHtPYmplY3R9IGRhdGEgRGVmaW5lIHRoZSBkYXRhIG9iamVjdCBpbiBhIGtleS12YWx1ZSBwYWlyXG4gIEByZXR1cm4ge1Byb21pc2V9IFRoZSBmdW5jdGlvbiByZXR1cm5zIHlvdSBhIHByb21pc2UuIFlvdSBjYW4gdXNlIHRoZSAndGhlbicgbWV0aG9kLCB0byB3YWl0IGZvciBpdC4gQWZ0ZXJ3YXJkcyB5b3UgZ2V0IGEgdHJ1ZSAod2hlbiBldmVyeXRoaW5nIHdhcyBmaW5lKSBvciBhbiBlcnJvciBvYmplY3QuXG4gICovXG4gIHVwZGF0ZShjb250YWluZXJfbmFtZSwgcm93X2lkLCBkYXRhKSB7XG4gICAgdmFyIGdsb2JhbF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvL0NoZWNrIHRoZSBwcm9wZXJ0aWVzIGJlZm9yZSBzZW5kaW5nIHRvIHRoZSBBUElcbiAgICAgIGlmIChjb250YWluZXJfbmFtZSA9PT0gdW5kZWZpbmVkIHx8IGNvbnRhaW5lcl9uYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJQbGVhc2UgZGVmaW5lIGEgY29udGFpbmVyLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3dfaWQgPT09IHVuZGVmaW5lZCB8fCBpc05hTihyb3dfaWQpKSB7XG4gICAgICAgIC8vQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyXG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIHJvdyBpZCBhbmQgbWFrZSBzdXJlIGl0IGlzIGEgbnVtYmVyLlwiKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IFtdIHx8IGRhdGEgPT09IHt9IHx8IGRhdGEgPT09IFwiXCIpIHtcbiAgICAgICAgcmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiUGxlYXNlIHByb3ZpZGUgYSBkYXRhIGFycmF5LCB3aXRoIGRhdGEgd2hpY2ggc2hvdWxkIGJlIHVwZGF0ZWQuXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGF4aW9zKHtcbiAgICAgICAgdXJsOiBDb25maWcuQVBJX0VORFBPSU5ULFxuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgYXBwc2VjcmV0OiBnbG9iYWxfdGhpcy5hcHBzZWNyZXQsXG4gICAgICAgICAgYXV0aHRva2VuOiBnbG9iYWxfdGhpcy5hdXRoX3Rva2VuXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBidWNrZXQ6IGdsb2JhbF90aGlzLmJ1Y2tldF9pZCxcbiAgICAgICAgICBkYXRhc2V0OiBlbmNvZGVVUkkoZ2xvYmFsX3RoaXMuZGF0YXNldCksXG4gICAgICAgICAgY29udGFpbmVyOiBlbmNvZGVVUkkoY29udGFpbmVyX25hbWUpLFxuICAgICAgICAgIHJvdzogcm93X2lkLFxuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IHNDUmVzdWx0KGRhdGEuc3RhdHVzLCBkYXRhLm1lc3NhZ2UsIGRhdGEuYm9keSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgdXBkYXRpbmcgdGhlIGRhdGEuIEZvbGxvd2luZyBlcnJvciBtZXNzYWdlOiBcIiArXG4gICAgICAgICAgICAgICAgZGF0YS5tZXNzYWdlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgVGhpcyBtZXRob2QgZGVsZXRlcyBhIHNwZWNpZmljIHJvdyBpbiBhIGNvbnRhaW5lciBvciBjYW4ganVzdCBkZWxldGUgYSBjb2x1bW4gaW4gYSBzcGVjaWZpYyByb3cuXG4gIEBwYXJhbSB7U3RyaW5nfSBjb250YWluZXJfbmFtZSBEZWZpbmUgdGhlIGNvbnRhaW5lciBuYW1lLCB3aGVyZSB0aGUgZGVsZXRpb24gcHJvY2VzcyBzaG91bGQgdGFrZSBwbGFjZVxuICBAcGFyYW0ge051bWJlcn0gcm93X2lkIERlZmluZSBhIHJvdyBpZCwgd2hpY2ggY2FuIGJlIHJldHJpZXZlZCBieSB0aGUgJ2dldCcgb3IgJ2dldEFsbCcgbWV0aG9kLlxuICBAcGFyYW0ge1N0cmluZ30gY29sdW1uIERlZmluZSBhIGNvbHVtbiBuYW1lLCB3aGVuIGp1c3QgdGhpcyBkYXRhIGluIHRoaXMgc3BlY2lmaWMgY29sdW1uIHNob3VsZCBiZSBkZWxldGVkLlxuICBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZS4gT25jZSBpdCBoYXMgZmluaXNoZWQgdGhlIGRlbGV0aW9uIHByb2Nlc3MgeW91IGNhbiBmZXRjaCB0aGUgcmVzdWx0IGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXG4gICovXG4gIGRlbGV0ZShjb250YWluZXJfbmFtZSwgcm93X2lkLCBjb2x1bW4pIHtcbiAgICB2YXIgZ2xvYmFsX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vQ2hlY2sgdGhlIHByb3BlcnRpZXMgYmVmb3JlIHNlbmRpbmcgdG8gdGhlIEFQSVxuICAgICAgaWYgKGNvbnRhaW5lcl9uYW1lID09PSB1bmRlZmluZWQgfHwgY29udGFpbmVyX25hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlBsZWFzZSBkZWZpbmUgYSBjb250YWluZXIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvd19pZCA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKHJvd19pZCkpIHtcbiAgICAgICAgLy9DaGVjayBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXJcbiAgICAgICAgcmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgcm93IGlkIGFuZCBtYWtlIHN1cmUgaXQgaXMgYSBudW1iZXIuXCIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGF4aW9zKHtcbiAgICAgICAgdXJsOiBDb25maWcuQVBJX0VORFBPSU5ULFxuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhcHBpZDogZ2xvYmFsX3RoaXMuYXBwaWQsXG4gICAgICAgICAgYXBwc2VjcmV0OiBnbG9iYWxfdGhpcy5hcHBzZWNyZXQsXG4gICAgICAgICAgYXV0aHRva2VuOiBnbG9iYWxfdGhpcy5hdXRoX3Rva2VuXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBidWNrZXQ6IGdsb2JhbF90aGlzLmJ1Y2tldF9pZCxcbiAgICAgICAgICBkYXRhc2V0OiBlbmNvZGVVUkkoZ2xvYmFsX3RoaXMuZGF0YXNldCksXG4gICAgICAgICAgY29udGFpbmVyOiBlbmNvZGVVUkkoY29udGFpbmVyX25hbWUpLFxuICAgICAgICAgIHJvdzogcm93X2lkLFxuICAgICAgICAgIGNvbDogY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBzQ1Jlc3VsdChkYXRhLnN0YXR1cywgZGF0YS5tZXNzYWdlLCBkYXRhLmJvZHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGRlbGV0aW5nIHRoZSBkYXRhLiBGb2xsb3dpbmcgZXJyb3IgbWVzc2FnZSB3YXMgcmVjZWl2ZWQ6IFwiICtcbiAgICAgICAgICAgICAgICBkYXRhLm1lc3NhZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG1ldGFkYXRhKGNvbnRhaW5lcl9uYW1lKSB7XG4gICAgdmFyIGdsb2JhbF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvL0NoZWNrIHRoZSBwcm9wZXJ0aWVzIGJlZm9yZSBzZW5kaW5nIHRvIHRoZSBBUElcbiAgICAgIGlmIChjb250YWluZXJfbmFtZSA9PT0gdW5kZWZpbmVkIHx8IGNvbnRhaW5lcl9uYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJQbGVhc2UgZGVmaW5lIGEgY29udGFpbmVyLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGF4aW9zKHtcbiAgICAgICAgdXJsOiBDb25maWcuQVBJX0VORFBPSU5UICsgXCJtZXRhZGF0YS5waHBcIixcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgYXBwaWQ6IGdsb2JhbF90aGlzLmFwcGlkLFxuICAgICAgICAgIGFwcHNlY3JldDogZ2xvYmFsX3RoaXMuYXBwc2VjcmV0LFxuICAgICAgICAgIGF1dGh0b2tlbjogZ2xvYmFsX3RoaXMuYXV0aF90b2tlblxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBidWNrZXQ6IGdsb2JhbF90aGlzLmJ1Y2tldF9pZCxcbiAgICAgICAgICBjb250YWluZXI6IGVuY29kZVVSSShjb250YWluZXJfbmFtZSlcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IHNDUmVzdWx0KGRhdGEuc3RhdHVzLCBkYXRhLm1lc3NhZ2UsIGRhdGEuYm9keSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgbWV0YWRhdGEuIEZvbGxvd2luZyBlcnJvciBtZXNzYWdlIHdhcyByZWNlaXZlZDogXCIgK1xuICAgICAgICAgICAgICAgIGRhdGEubWVzc2FnZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qXG5SZXN1bHQgb2JqZWN0IGZvciBmaWx0ZXJpbmcgdGhlXG4qL1xuZXhwb3J0IGNsYXNzIHNDUmVzdWx0IHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzX2NvZGUsIG1lc3NhZ2UsIGJvZHkpIHtcbiAgICB0aGlzLnN0YXR1c19jb2RlID0gc3RhdHVzX2NvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBib2R5O1xuICB9XG5cbiAgZ2V0IGlzT0soKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzX2NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzX2NvZGUgPD0gMjk5ID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsImV4cG9ydHMuaXNhdHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbmZ1bmN0aW9uIFJlYWRTdHJlYW0oKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHR5LlJlYWRTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG59XG5leHBvcnRzLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtO1xuXG5mdW5jdGlvbiBXcml0ZVN0cmVhbSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0dHkuUmVhZFN0cmVhbSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn1cbmV4cG9ydHMuV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==